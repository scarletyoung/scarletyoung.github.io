---
title: Nvidia GPU Architecture
hide: true
---

# CUDA
CUDA是一个硬件和软件架构，可以让NVIDIA的GPU来执行由C、C++、Fortran、OpenCL、DirectCompute和其他语言写的程序。

CUDA程序调用并行内核，内核在一组并行的线程中并行地执行。编译器组织以线程块和线程块网格的方式来组织线程，GPU在并行线程块的一个网格中初始化内核程序，线程块的每个线程执行一个内核程序的实例，并且有自己的线程ID。

线程块是一组并发执行的线程，这些线程可以通过屏障同步和共享内存相互协作，每个线程块有自己的ID。

一个网格是线程块数组，它们执行相同的内核，从全局内存中读取输入并向全局内存中写入输出，在独立的内核调用之间进行同步。

在CUDA编程模型中，每个线程有自己的私有内存空间。每个线程块有块共享内存，用于线程间通信、数据共享和结果共享。线程块网格在全局内存空间中共享结果。

CUDA与GPU的映射关系是
* 一个GPU执行一个或多个内核网格。
* 一个流式多处理器（SM）执行一个或多个线程块
* SM中的CUDA核和其他执行单元执行线程。

SM以32个线程为一组执行，称为一个warp。可以通过让wrap中的线程执行相同的代码路径并访问附近地址的内存来极大地提高性能。

# Fermi

Fermi主要关注以下方面的改进
* 改进了说精度浮点的性能
* 支持ECC
* 缓存层级
* 更多的共享内存
* 更快的上下文切换
* 更快的原子操作

Fermi架构的主要亮点如下
* 第三代流式多处理器（SM）
  * 每个流式多处理器有32个CUDA，是GT200的四倍
  * 双精度浮点数的性能峰值时GT200的八倍
  * Dual Wrap调度器同时调度，派发来自两个独立的warp中的指令
  * 配置共享内存和L1缓存的64MB RAM
* 第二代并行线程执行ISA
  * 完整C++支持的统一地址空间
  * 为OpenCL和DirectCompute进行了优化
  * 完整的IEEE 754-2008 32位和64为精度
  * 带64位扩展的完整32位整型路径
  * 支持过渡到64位寻址的内存访问指令
  * 通过预测改进了性能
* 改进的内存子系统
  * 带有可配置的L1缓存和统一L2缓存的NVIDIA并行数据缓存层级
  * 带有ECC内存支持（第一个）
  * 极大地改进了原子内存操作性能
* NVIDIA GigaThread Engine
  * 10倍的上下文切换速度
  * 并发内核执行
  * 乱序线程阻塞执行
  * 双重叠内存传输引擎

## 架构总览
架构图如下所示

* 最多有512个CUDA核，每32个核组织成一个SM，共有16个SM。
* 6个64位显存分区，384位显存接口，支持高达6GB的GDDR5 DRAM显存。
* 通过PCI-Express链接GPU和CPU。
* GigaThread全局调度器将线程块分发给SM线程调度器。

### 第三代流式多处理器
每个CUDA核有一个完全流水化的整型运算单元（ALU）和浮点运算单元（FPU）。架构实现了新的IEEE 754-2008浮点标准，为单精度和双精度算数提供了融合乘加（FMA）指令，FMA改进了MAD指令，通过使用单个最终舍入步骤执行乘法和加法而不会损失加法精度。

整型ALU支持所有指令的全32位精度，可以有效支持64位和扩展精度运算。

每个SM有16个load/store单元，允许每个时钟周期位16个线程计算源和目的地址。

特殊功能单元（SFU）执行sin、cos、倒数和求根指令，每个SFU每个线程执行一条指令，A warp执行八个时钟周期。SFU管道与调度单元解耦，允许在SFU占用的情况下向其他执行单元发出指令。

每个SM每个时钟周期可以最多执行16个双精度FMA操作。（这个不会是用两个CUDA来执行一个双精度FMA吧？）

每个SM以32个并行线程为一组进行调度，称为warp。每个SM有两个warp调度器和两个指令派发单元，允许发射和并行执行两个warp。双warp调度器选择两个warp，从每个warp中发射一条指令到16个核、16个load/store单元或4个SFU。大部分指令可以双重发射，但是双精度指令不支持与任何其他操作进行双重调度。

每个SM有64KB可配置的共享内存和L1缓存。共享内存是的线程块内的线程可以进行合作、促进了数据重用并且极大地减少了芯片外的数据流，从而提高了GPU的性能。
64KB的内存有两种配置
* 48KB的共享内存和16KB的L1缓存
* 16KB的共享内存和48KB的L1缓存

## 第二代并行线程执行ISA
Fermi架构支持新的并行线程执行（PTX）2.0指令集，PTX是低级虚拟机和ISA，用于支持并线线程处理器的操作。程序安装时，PTX指令被GPU驱动翻译为机器指令。

PTX的主要目标是
* 提供跨越多代GPU的稳定ISA
* 在已编译的应用上，实现完整的GPU性能
* 为其他编译目标提供机器独立的ISA
* 为应用和中间件开发者提供代码分发ISA
* 为优化代码生成器和翻译器提供通用的ISA，可以将PTX映射到特定的目标机器
* 促进库和性能内核的手动编码
* 提供可扩展的编程模型，涵盖从几个内核到多个并行内核的GPU大小。

PTX 2.0增加了对IEEE 32为浮点精度的完整支持，对所有变量和指针统一的地址空间，64为地址以及为OpenCL和DirectCompute增加的新指令。

PTX 2.0提供了对C++的完整支持。

### 统一地址空间从而能够完整地支持C++
PTX 2.0对线程私有的局部地址空间、线程块的共享地址空间和全局地址空间进行了统一编码，可以在编译时就知道load和store指令对哪个地址空间进行操作，从而可以支持C和C++的指针。

### 为OpenCL和DirectCompute进行优化
OpenCL和DirectCompute与CUDA编程模型非常相似，有类似的抽象，如线程、线程块、线程块网格、栅栏同步、线程的共享内存、全局内存和原子操作。

Fermi提供了对表面指令格式转换的硬件支持。PTX 2.0 ISA还增加了对DirectCompute指令population计数、追加和位翻转的支持。

### IEEE 32位精度浮点数
单精度浮点指令在硬件中默认支持次正规数，并且还支持所有IEEE 754-2008的舍入模式。




实现了所有DirectX 11的硬件特征，包括曲面细分和DirectCompute（DirectCompute是微软的一个API接口，允许使用GPU进行通用计算）。

设计目标

1. 卓越的游戏性能：翻新了几何管线，加倍了CUDA核，加倍了ROP，提高了填充率。
2. 一流的图像质量：实现了新的32CSAA
3. 电影级的几何真实感：全新的分布式几何处理架构，使用多个PolyMorph引擎实现。并行几何处理能力
4. 革命性的游戏计算架构：图形和物理之间更快的上下文切换，并发计算内核执行和增强的缓存架构，增加原子操作性能。

在图形学、线性代数和科学应用中的常用操作是两个数相乘，然后将乘积加上第三个数，如$D = A \times B + C$。
上一代GPU使用了MAD指令可以在单个时钟中执行上述操作，但是乘积结果会先截断然后在进行加法。
Fermi实现的了FMA指令，对MAD进行了改进，乘积的结果不会被截断，而是保留了所有精度，然后进行相加。
【image】

### 通过预测改进条件性能


# Kepler

由于Fermi架构存在严重的发热问题，Kepler架构除了提供高性能外，一个设计的重点是提升性能功耗比。

## 架构

Kepler由不同配置图形处理集群（GPCs）、流式多处理器（SMs）和内存控制器组成。

下图是GTX 680的架构，有四个GPCs，八个下一代SMX和四个内存控制器。

![image-20211123082140331](/Users/shellingford/Library/Application Support/typora-user-images/image-20211123082140331.png)

每个GPC有专用的光栅引擎和两个SMX单元，GTX 680实现有8个SMX单元，共有1546个CUDA核。

完全修改了内存子系统，显著提高了内存时钟速度。每个内存控制器有一个128BK的L2缓存和8个ROP（Render output unit）单元，每个ROP单元可以处理一个颜色样本。GTX 680有4个内存控制器，共有512KB的L2缓存和32个ROP单元

## 下一代SM总览

Kepler架构有256个SFU单元，128个纹理单元，在芯片级，关键操作（FMA32，SFU操作和纹理操作）的吞吐量得到了显著提升，其他操作的吞吐量保持不变。

由于面积效率的原因，Kepler将这些单元划分为8个SMX，与Fermi架构相比减少了。因此每个SMX有更多的计算单元，更大的吞吐量。

## 下一代SMX架构详情

![image-20211230224848728](/Users/shellingford/Library/Application Support/typora-user-images/image-20211230224848728.png)

SMX包含了4个warp调度器，每个warp每个时钟周期可以调度两条指令。

调度功能进行了重新设计，更加关注能耗。

Kepler和Fermi调度器都包含了

1. 长延迟操作的寄存器记分板
2. interwarp调度决策
3. 线程块级的调度。

Fermi架构包含了复杂的硬件了防止数据冒险。但是，这些信息是确定的（不知道为什么？），因此，kepler中可以使用简单的硬件了取代了复杂的硬件，节省了能耗。

处理器执行核心开发了一种新设计，专注于每瓦最佳性能。 最大限度地提高时钟门控效率，最大限度地减少布线和重新定时开销。