---
title: Nvidia GPU Architecture
hide: true
---

# CUDA
CUDA是一个硬件和软件架构，可以让NVIDIA的GPU来执行由C、C++、Fortran、OpenCL、DirectCompute和其他语言写的程序。

CUDA程序调用并行内核，内核在一组并行的线程中并行地执行。编译器组织以线程块和线程块网格的方式来组织线程，GPU在并行线程块的一个网格中初始化内核程序，线程块的每个线程执行一个内核程序的实例，并且有自己的线程ID。

线程块是一组并发执行的线程，这些线程可以通过屏障同步和共享内存相互协作，每个线程块有自己的ID。

一个网格是线程块数组，它们执行相同的内核，从全局内存中读取输入并向全局内存中写入输出，在独立的内核调用之间进行同步。

在CUDA编程模型中，每个线程有自己的私有内存空间。每个线程块有块共享内存，用于线程间通信、数据共享和结果共享。线程块网格在全局内存空间中共享结果。

CUDA与GPU的映射关系是
* 一个GPU执行一个或多个内核网格。
* 一个流式多处理器（SM）执行一个或多个线程块
* SM中的CUDA核和其他执行单元执行线程。

SM以32个线程为一组执行，称为一个warp。可以通过让wrap中的线程执行相同的代码路径并访问附近地址的内存来极大地提高性能。

# Fermi

Fermi主要关注以下方面的改进
* 改进了说精度浮点的性能
* 支持ECC
* 缓存层级
* 更多的共享内存
* 更快的上下文切换
* 更快的原子操作

Fermi架构的主要亮点如下
* 第三代流式多处理器（SM）
  * 每个流式多处理器有32个CUDA，是GT200的四倍
  * 双精度浮点数的性能峰值时GT200的八倍
  * Dual Wrap调度器同时调度，派发来自两个独立的warp中的指令
  * 配置共享内存和L1缓存的64MB RAM
* 第二代并行线程执行ISA
  * 完整C++支持的统一地址空间
  * 为OpenCL和DirectCompute进行了优化
  * 完整的IEEE 754-2008 32位和64为精度
  * 带64位扩展的完整32位整型路径
  * 支持过渡到64位寻址的内存访问指令
  * 通过预测改进了性能
* 改进的内存子系统
  * 带有可配置的L1缓存和统一L2缓存的NVIDIA并行数据缓存层级
  * 带有ECC内存支持（第一个）
  * 极大地改进了原子内存操作性能
* NVIDIA GigaThread Engine
  * 10倍的上下文切换速度
  * 并发内核执行
  * 乱序线程阻塞执行
  * 双重叠内存传输引擎

## 架构总览
架构图如下所示

* 最多有512个CUDA核，每32个核组织成一个SM，共有16个SM。
* 6个64位显存分区，384位显存接口，支持高达6GB的GDDR5 DRAM显存。
* 通过PCI-Express链接GPU和CPU。
* GigaThread全局调度器将线程块分发给SM线程调度器。

### 第三代流式多处理器
每个CUDA核有一个完全流水化的整型运算单元（ALU）和浮点运算单元（FPU）。架构实现了新的IEEE 754-2008浮点标准，为单精度和双精度算数提供了融合乘加（FMA）指令，FMA改进了MAD指令，通过使用单个最终舍入步骤执行乘法和加法而不会损失加法精度。

整型ALU支持所有指令的全32位精度，可以有效支持64位和扩展精度运算。

每个SM有16个load/store单元，允许每个时钟周期位16个线程计算源和目的地址。

特殊功能单元（SFU）执行sin、cos、倒数和求根指令，每个SFU每个线程执行一条指令，A warp执行八个时钟周期。SFU管道与调度单元解耦，允许在SFU占用的情况下向其他执行单元发出指令。

每个SM每个时钟周期可以最多执行16个双精度FMA操作。（这个不会是用两个CUDA来执行一个双精度FMA吧？）

每个SM以32个并行线程为一组进行调度，称为warp。每个SM有两个warp调度器和两个指令派发单元，允许发射和并行执行两个warp。双warp调度器选择两个warp，从每个warp中发射一条指令到16个核、16个load/store单元或4个SFU。大部分指令可以双重发射，但是双精度指令不支持与任何其他操作进行双重调度。

每个SM有64KB可配置的共享内存和L1缓存。共享内存是的线程块内的线程可以进行合作、促进了数据重用并且极大地减少了芯片外的数据流，从而提高了GPU的性能。
64KB的内存有两种配置
* 48KB的共享内存和16KB的L1缓存
* 16KB的共享内存和48KB的L1缓存

## 第二代并行线程执行ISA
Fermi架构支持新的并行线程执行（PTX）2.0指令集，PTX是低级虚拟机和ISA，用于支持并线线程处理器的操作。程序安装时，PTX指令被GPU驱动翻译为机器指令。

PTX的主要目标是
* 提供跨越多代GPU的稳定ISA
* 在已编译的应用上，实现完整的GPU性能
* 为其他编译目标提供机器独立的ISA
* 为应用和中间件开发者提供代码分发ISA
* 为优化代码生成器和翻译器提供通用的ISA，可以将PTX映射到特定的目标机器
* 促进库和性能内核的手动编码
* 提供可扩展的编程模型，涵盖从几个内核到多个并行内核的GPU大小。

PTX 2.0增加了对IEEE 32为浮点精度的完整支持，对所有变量和指针统一的地址空间，64为地址以及为OpenCL和DirectCompute增加的新指令。

PTX 2.0提供了对C++的完整支持。

### 统一地址空间从而能够完整地支持C++
PTX 2.0对线程私有的局部地址空间、线程块的共享地址空间和全局地址空间进行了统一编码，可以在编译时就知道load和store指令对哪个地址空间进行操作，从而可以支持C和C++的指针。

### 为OpenCL和DirectCompute进行优化
OpenCL和DirectCompute与CUDA编程模型非常相似，有类似的抽象，如线程、线程块、线程块网格、栅栏同步、线程的共享内存、全局内存和原子操作。

Fermi提供了对表面指令格式转换的硬件支持。PTX 2.0 ISA还增加了对DirectCompute指令population计数、追加和位翻转的支持。

### IEEE 32位精度浮点数
单精度浮点指令在硬件中默认支持次正规数，并且还支持所有IEEE 754-2008的舍入模式。

次正规数是位于0和最小正规数之间的数字，之前的GPU会将次正规数舍入为零，因此会损失精度。Fermi的浮点运算单元在硬件中处理次正规数，在可以处理正规数的时候不会影响性能。

GPU中经常进行的操作序列是两个数相乘，结果在加上第三个数。之前的GPU使用MAD指令技术来加速这个功能。但是MAD指令会对相乘的结果进行截断，因此会损失精度。

而Fermi架构中使用了新的FMA指令，在相乘的时候可以保留中间阶段的精度，使得最终结果的精度增加了。

### 通过预测来改进条件的性能
用于不同线程管理的硬件预测器现在支持指令集的预测，预测器可以使得短的条件代码段能够高效执行，不会产生分支指令的开销。

## 内存子系统改进
### 有可配置的L1缓存和统一的L2缓存的并行数据缓存
由于不同应用程序对于缓存和共享内存需求的不同，因此，最好的内存层级应该允许程序进行选择。

之前的GPU架构只支持对纹理操作的加载路径和为像素数据输出的只写的导出路径。这个方法是不适用于执行通用程序。

Fermi架构为load和store指令实现单一统一内存请求，每个SM有一个L1缓存和为所有SM提供服务的L2缓存。其中L1缓存时可配置的，可以根据应用程序的需求配置为48KB的共享内存和16KB的L1缓存或者是16KB的共享内存和48KB的L1缓存。

L1缓存还有助于缓存复杂程序的临时寄存器溢出，上一代会将移除存储的DRAM，增加了访问延迟。

### 第一个具有ECC内存支持的GPU
Fermi支持基于纠错码（ECC）来保护内存数据，可以增强数据的完整性行。

Fermi实现的ECC可以检二纠一（SECDED），SECDED可以保证可以检测出两比特错误和多比特错误。

Fermi架构的寄存器堆、共享内存、L1缓存、L2缓存以及DRAM都增加了ECC保护，增加了GPU的可靠性。

### 快速原子内存操作

## GigaThread线程调度器
两级分布式线程调度器是fermi架构的重要改进之一。在芯片层面，全局工作分配引擎将线程块调度到各个SM；在SM层级，每个warp调度器将32个线程的warp分配到执行单元。

新一代的线程调度器提供了更高的线程吞吐量、显著增加了上下文切换、并发内核执行以及改进了线程块调度
* 在上下文切换方面，fermi流水线可以将线程切换的时间降低到25微妙以下。
* Fermi支持同一应用上下文的不同内核可以同时在GPU上并发执行，最大限度地利用GPU资源。




# Kepler

由于Fermi架构存在严重的发热问题，Kepler架构除了提供高性能外，一个设计的重点是提升性能功耗比。

## 架构

Kepler由不同配置图形处理集群（GPCs）、流式多处理器（SMs）和内存控制器组成。

下图是GTX 680的架构，有四个GPCs，八个下一代SMX和四个内存控制器。

![image-20211123082140331](/Users/shellingford/Library/Application Support/typora-user-images/image-20211123082140331.png)

每个GPC有专用的光栅引擎和两个SMX单元，GTX 680实现有8个SMX单元，共有1546个CUDA核。

完全修改了内存子系统，显著提高了内存时钟速度。每个内存控制器有一个128BK的L2缓存和8个ROP（Render output unit）单元，每个ROP单元可以处理一个颜色样本。GTX 680有4个内存控制器，共有512KB的L2缓存和32个ROP单元

## 下一代SM总览

Kepler架构有256个SFU单元，128个纹理单元，在芯片级，关键操作（FMA32，SFU操作和纹理操作）的吞吐量得到了显著提升，其他操作的吞吐量保持不变。

由于面积效率的原因，Kepler将这些单元划分为8个SMX，与Fermi架构相比减少了。因此每个SMX有更多的计算单元，更大的吞吐量。

## 下一代SMX架构详情

![image-20211230224848728](/Users/shellingford/Library/Application Support/typora-user-images/image-20211230224848728.png)

SMX包含了4个warp调度器，每个warp每个时钟周期可以调度两条指令。

调度功能进行了重新设计，更加关注能耗。

Kepler和Fermi调度器都包含了

1. 长延迟操作的寄存器记分板
2. interwarp调度决策
3. 线程块级的调度。

Fermi架构包含了复杂的硬件了防止数据冒险。但是，这些信息是确定的（不知道为什么？），因此，kepler中可以使用简单的硬件了取代了复杂的硬件，节省了能耗。

处理器执行核心开发了一种新设计，专注于每瓦最佳性能。 最大限度地提高时钟门控效率，最大限度地减少布线和重新定时开销。