

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <meta name="description" content="View C++ as a federation of languages C++ contains four main sublanguages  c, block, statement, preprocessor, build-in data type, arrays, pointers, etc. Object-Oriented C++, class, encapsulation, inh">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective C++ Note">
<meta property="og:url" content="http://example.com/2021/12/09/Effective%20C++/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="View C++ as a federation of languages C++ contains four main sublanguages  c, block, statement, preprocessor, build-in data type, arrays, pointers, etc. Object-Oriented C++, class, encapsulation, inh">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-12-08T16:00:00.000Z">
<meta property="article:modified_time" content="2022-01-06T12:49:10.653Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  <title>Effective C++ Note - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":"UA-177876633-1","gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>成长之路</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Effective C++ Note">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-12-09 00:00" pubdate>
        2021年12月9日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      60k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      187 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Effective C++ Note</h1>
            
            <div class="markdown-body">
              <h1 id="view-c-as-a-federation-of-languages"><a class="markdownIt-Anchor" href="#view-c-as-a-federation-of-languages"></a> View C++ as a federation of languages</h1>
<p>C++ contains four main sublanguages</p>
<ol>
<li>c, block, statement, preprocessor, build-in data type, arrays, pointers, etc.</li>
<li>Object-Oriented C++, class, encapsulation, inheritance, polymorphism, virtual functions, etc.</li>
<li>template c++,</li>
<li>STL</li>
</ol>
<p>C++ is a federation of languages, so when you switch from one sublanguage to another, programming strategy should be change too.</p>
<h1 id="prefer-consts-enums-and-inlines-to-defines"><a class="markdownIt-Anchor" href="#prefer-consts-enums-and-inlines-to-defines"></a> Prefer consts, enums, and inlines to #defines</h1>
<p>Reason</p>
<ol>
<li>The symbolic name may never be seen by compilers and may not get entered into the symbolic table, So when an error occurs, the error message may not refer to the symbolic name and you’d have no idea where the constant came from.</li>
<li>#define could result in multiple copies, because of preprocessor’s blind substitution of macro name with value.</li>
<li>#define can’t be used to provide any kind of encapsulation.</li>
<li>macro function has so many drawbacks, for example</li>
</ol>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CALL_WITH_MAX(a,b) f((a) &gt; (b) ? (a) : (b))</span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>, b = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">CALL_WITH_MAX</span>(++a, b);  \\ <span class="hljs-function">a is incremented twice</span><br><span class="hljs-function"><span class="hljs-title">CALL_WITH_MAX</span><span class="hljs-params">(++a, b+<span class="hljs-number">10</span>)</span></span>;  \\ a is incremented once<br></code></pre></td></tr></table></figure>
<p>Solution</p>
<ol>
<li>Replace macro with a constant. but there are two special cases
<ol>
<li>
<p>Defining constant pointers, should use two const. For example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;abc&#x27;</span>;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>Class-specific constant, should may a constant as a static member. For example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GamePlayer</span> &#123;</span><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> NumTurns = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">int</span> scores[NumTurns];<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>When type is integral(integers, chars, bools) type, you can declare and use them without definition. The defination will be put in an implementation file, not a header file.</p>
<p>Some older compiler may not accept the syntax above. In this case, should put the initial value at the point of definition. But when you need the value of the constant during compilation of the class, such as in the declaration above. The solution is known as “the enum hack” shown as below</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GamePlayer</span> &#123;</span><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span>NumTurns = <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">int</span> scores[NumTurns];<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>Replace macro function with inline function.</li>
</ol>
<h1 id="use-const-whenever-possible"><a class="markdownIt-Anchor" href="#use-const-whenever-possible"></a> Use const whenever possible</h1>
<h2 id="iterator-with-const"><a class="markdownIt-Anchor" href="#iterator-with-const"></a> Iterator with const</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> std::vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator iter = vec.<span class="hljs-built_in">begin</span>();  <span class="hljs-comment">//iter acts like a T* const. it means that data can be changed but iter is const</span><br>std::vector&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator iter = vec.<span class="hljs-built_in">begin</span>();  <span class="hljs-comment">//inter acts like a const T*. It measn that iter can be changed but data(*iter) is const</span><br></code></pre></td></tr></table></figure>
<h2 id="constant-returned-values"><a class="markdownIt-Anchor" href="#constant-returned-values"></a> Constant returned values</h2>
<p>Constant returned values sometimes can reduce the incidence of client errors. For example,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rational</span> &#123;</span>...&#125;<br><span class="hljs-keyword">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> Rational&amp; lhs, <span class="hljs-keyword">const</span> Rational&amp; rhs);<br>Rational a,b,c;<br><br><span class="hljs-keyword">if</span> (a*b=c) ...  <span class="hljs-comment">// a typo. but if returned value is not constant, then it will pass compilation.</span><br></code></pre></td></tr></table></figure>
<h2 id="const-member-functions"><a class="markdownIt-Anchor" href="#const-member-functions"></a> Const member functions</h2>
<p>The reason for using const member functions</p>
<ol>
<li>Can know which functions may be invoked on const objects.</li>
<li>Can know which functions may modify an object and which may not.</li>
<li>Work with const object.</li>
</ol>
<p>Const function and non-const function can be overloaded, for example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextBlock</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-keyword">size_t</span> position) <span class="hljs-keyword">const</span>;  <span class="hljs-comment">// for const object</span><br>    <span class="hljs-keyword">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-keyword">size_t</span> position);  <span class="hljs-comment">// for non-const object</span><br>  <span class="hljs-keyword">private</span>:<br>    std::string text;<br>&#125;;<br><span class="hljs-function">TextBlock <span class="hljs-title">tb</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">const</span> TextBlock <span class="hljs-title">ctb</span><span class="hljs-params">(<span class="hljs-string">&quot;World&quot;</span>)</span></span>;<br>std::cout &lt;&lt; tb[<span class="hljs-number">0</span>];  <span class="hljs-comment">// fine</span><br>tb[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;x&#x27;</span>;  <span class="hljs-comment">// fine</span><br>std::cout &lt;&lt; ctb[<span class="hljs-number">0</span>];  <span class="hljs-comment">// fine</span><br>ctb[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;x&#x27;</span>;  <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure>
<p>Notice, the return type of the non-const operator[] is a reference. But, if the type is a simple char, it is illegal to modify the return value of a function that returns a build-in type.</p>
<p>There two type of const, bitwise constness and logical constness.<br />
C++ is designed for bitwise constness, but there is a exception. For example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CTextBlock</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-keyword">size_t</span> position) <span class="hljs-keyword">const</span>;  <span class="hljs-comment">// inappropriate declaration</span><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">char</span> *pText;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">const</span> CTextBlock <span class="hljs-title">cctb</span><span class="hljs-params">(<span class="hljs-string">&quot;World&quot;</span>)</span></span>;<br><span class="hljs-keyword">char</span> *pc = &amp;cctb[<span class="hljs-number">0</span>];<br>*pc = <span class="hljs-string">&#x27;J&#x27;</span>;  <span class="hljs-comment">// can pass</span><br></code></pre></td></tr></table></figure>
<p>If any member value may be modified and it should be valid for const. You should add a mutable modifier. For example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CTextBlock</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::<span class="hljs-keyword">size_t</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">char</span> *pText;<br>    multable std::<span class="hljs-keyword">size_t</span> textLength;<br>    multable <span class="hljs-keyword">bool</span> lenghtIsValid;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="avoidng-duplicatio-in-const-and-non-const-member-functions"><a class="markdownIt-Anchor" href="#avoidng-duplicatio-in-const-and-non-const-member-functions"></a> Avoidng Duplicatio in const and Non-const Member Functions</h2>
<p>In TextBlock class, we overloaded operator[] function for const and non-const. If we performed bounds checking, it will yields code duplication.<br />
The solution is below</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextBlock</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-keyword">size_t</span> position) <span class="hljs-keyword">const</span>;<br>    <span class="hljs-keyword">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-keyword">size_t</span> position) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">char</span>&amp;&gt;(  <span class="hljs-comment">// cast the const char&amp; to non-const char&amp;</span><br>        <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">const</span> TextBlock&amp;&gt;(*<span class="hljs-keyword">this</span>)[position]  <span class="hljs-comment">// we want to call the const op[], but we can not directly do that, because it will call itself and result in infinite recursion. Instead, we should cast this object to const type(cosnt TextBlock&amp;) so that we can call const version.</span><br>      );<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="make-sure-that-objects-are-initialized-before-theyre-used"><a class="markdownIt-Anchor" href="#make-sure-that-objects-are-initialized-before-theyre-used"></a> Make sure that objects are initialized before they’re used</h1>
<p>C++对象的初始化规则通常比较复杂，最好的方法就是在使用之前进行初始化。<br />
对于对象的成员，我们应该使用初始化列表进行初始化而不是在构造函数内赋值，初始化列表通常比较高效，初始化列表中的参数会作为成员构造器的参数进行对象创建，而在构造器内赋值时，会先调用成员对象的默认构造器（实际上时在进入构造体之前调用的）然后在进行赋值（构造器内实际上是赋值而不是初始化）。<br />
当初始化列表中没有参数的时候，会调用成员对象的默认构造器，如下所示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ABEntry::<span class="hljs-built_in">ABEntry</span>(): <span class="hljs-built_in">theName</span>(),<span class="hljs-built_in">theAddress</span>(),<span class="hljs-built_in">thePhones</span>() &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>但是，当成员对象是引用或常量时，则必须在初始化列表中进行初始化，因为，他们不能进行赋值。<br />
对于从文件中或数据库中获取对象值的类来说，较好的方法是使用一个私有的函数进行赋值，其他构造函数调用这个函数。而对于其他方式来说，使用初始化列表是更好的选择。</p>
<p>初始化列表的顺序是成员在类中声明的顺序，而不是在初始化列表中的顺序。</p>
<p>静态对象，包括全局对象，命名空间内定义的对象，类内的静态对象、函数内声明的静态对象以及在文件范围内声明为静态的对象，从构造后到程序结束是一直存在。函数内的静态对象成为局部静态对象，其他称为非局部静态对象。<br />
一个翻译单元是产生单个目标文件的源代码，通常是一个源文件加上include的所有文件。<br />
若在一个翻译单元中的非局部静态对象使用了另一个翻译单元的非局部静态对象，这个对象可能是未初始化的，因为在两个不同翻译单元的非局部静态变量的初始化顺序是未定义的。<br />
一个解决方式是将非局部静态对象移动到函数中定义，使其成为局部的静态变量，使用函数调用获取对象的该引用，类似于单例。示例如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//file_system.cpp</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSystem</span>&#123;</span>...&#125;;<br><span class="hljs-function">FileSystem&amp; <span class="hljs-title">tfs</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> FileSystem fs;<br>  <span class="hljs-keyword">return</span> fs;<br>&#125;<br><span class="hljs-comment">// direcotry.cpp</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Directory</span>&#123;</span>...&#125;;<br>Direcotry::<span class="hljs-built_in">Directory</span>(params) &#123;<br>  ...<br>  std::<span class="hljs-keyword">size_t</span> disks = <span class="hljs-built_in">tfs</span>().<span class="hljs-built_in">numDisks</span>();<br>  ...<br>&#125;;<br><span class="hljs-function">Directory&amp; <span class="hljs-title">tempDir</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">static</span> Direcotry <span class="hljs-title">td</span><span class="hljs-params">(params)</span></span>;<br>  <span class="hljs-keyword">return</span> td;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="know-what-functions-c-silently-writes-and-calls"><a class="markdownIt-Anchor" href="#know-what-functions-c-silently-writes-and-calls"></a> Know what functions c++ silently writes and calls</h1>
<p>For a class, if you don’t declare them yourself, compilers will declare their own version of a copy constructor, a copy assignment operator, and a destructor(If they are needed). If you do not declare any constructor, compilers will also declare a default constructor.<br />
The following two declaration is essentially the same.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// declaration one</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Empty</span>&#123;</span>&#125;;<br><span class="hljs-comment">// declaration two</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Empty</span>&#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Empty</span>()&#123;&#125;<br>    <span class="hljs-built_in">Empty</span>(<span class="hljs-keyword">const</span> Emtpy&amp; rhs)&#123;&#125;<br>    ~<span class="hljs-built_in">Empty</span>()&#123;&#125;<br><br>    Empty&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Empty&amp; rhs)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>The generated destructor usually is non-vitual unless its base class declares a virtual destructor.</p>
<p>The copy constructor and the copy assignment operator will simply copy each non-static data member. But if a class contains a reference member or a const member, compiler won’t generate a default copy assignment operator. You must define the copy assignment operator yourself.</p>
<p>If the copy assignment operator of the base class is private, compilers will not refuse to generator default copy assignment operator.</p>
<h1 id="explicitly-dissallow-the-use-of-compiler-generated-functions-you-do-not-want"><a class="markdownIt-Anchor" href="#explicitly-dissallow-the-use-of-compiler-generated-functions-you-do-not-want"></a> Explicitly dissallow the use of compiler-generated functions you do not want.</h1>
<p>If you do not want to support copying, you can’t just simply not declaring copy constructor and copy assignment operator, beacuse compilers will generate them when needed.</p>
<p>One scheme is declare the copy constructor and copy assignment operator private and do not define them. For example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeForSale</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">HomeForSale</span>(<span class="hljs-keyword">const</span> HomeForSale&amp;);<br>    HomeForSale&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> HomeForSale&amp;);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>The solution above has a problem: it can pass compiler and cause link-time error.</p>
<p>The another scheme that move the link-time error up to compile time is that declaring the copy contructor and copy assignment operator private in the base class instead of HomeForSale class. For example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Uncopyable</span> &#123;</span><br>  <span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">Uncopyable</span>()&#123;&#125;<br>    ~<span class="hljs-built_in">Uncopyalbe</span>()&#123;&#125;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Uncopyable</span>(<span class="hljs-keyword">const</span> Uncopyable&amp;);<br>    Uncopyable&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Uncopyable&amp;);<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeForSale</span> :</span> <span class="hljs-keyword">private</span> Uncopyable&#123;<br><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>This work because compilers will try to generator copy constructor and copy assignment operator and these functions will try to call their base counterparts and fails.<br />
This solution include some subtleties</p>
<ol>
<li>Multiple inheritance.</li>
</ol>
<h1 id="declare-destructor-virtual-in-polymorphic-base-classes"><a class="markdownIt-Anchor" href="#declare-destructor-virtual-in-polymorphic-base-classes"></a> Declare destructor virtual in polymorphic base classes</h1>
<p>In C++, when a derived class object is deleted through a pointer to a base class with a non-virtual destructor, result are undefined. The derived part of the object may never be destroyed at the runtime, thus leading to a curious partially destroyed object.</p>
<p>The solution is that give the base class a virtual destructor. Any class with virtual functions should almost certainly have a virtual destructor, Because if a class does not contain virtual functions, it is not meant to be used as a base class.</p>
<p>When a class is not intended to be a base class, making the destructor virtual is usually a bad idea. Assume we have a class below</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Point</span>(<span class="hljs-keyword">int</span> xCoord, <span class="hljs-keyword">int</span> yCoord);<br>    ~<span class="hljs-built_in">Point</span>();<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> x, y;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>If an int occupies 32 bits, then a Point object is 64 bits. Furthermore, such a Point object can be pass as a 64-bit quantity to functions written in other languages, such as C.</p>
<p>But if Point’s desctructor is virtual, the object will contain a additional pointer called vptr(virtual table pointer). The Point objects will increase in size. As a result, it is no longer possible to pass Points to and from functions written in other languages.</p>
<p>You must provide a definition for the pure virtual destrcutor. Compiler will generate a call to base class desctructor from its derived classes’ destructors. If you don’t, the linker will complain.</p>
<p>This rule applies only to polymorphic base classes.</p>
<h1 id="prevent-exceptions-from-leaving-desctructors"><a class="markdownIt-Anchor" href="#prevent-exceptions-from-leaving-desctructors"></a> Prevent exceptions from leaving desctructors</h1>
<p>Emitting exceptions from destructors is not a good idea.<br />
Consider below the class</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Widget</span>() &#123;...&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>  std::vector&lt;Widget&gt; v;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>When the vector v is destroyed, it will destroying all the Widgets in it. Assume an exception is thrown during destruction of the first one. The other Widgets still have to be destroyed. So, if another destructor is called and throws an exception, there are two simultaneously active exceptions. In this situation, program execution either terminates or yields underfined behavior.</p>
<p>There are two solutions</p>
<ol>
<li>Terminate the program.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">DBConn::~<span class="hljs-built_in">DBConn</span>() &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    db.<span class="hljs-built_in">close</span>();<br>  &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span>(...) &#123;<br>    ...<br>    std::<span class="hljs-built_in">abort</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>swallow the exception. When choosing this scheme, the program must be able to reliably continue execuftion even after an error has been encountered and ignored.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">DBConn::~<span class="hljs-built_in">DBConn</span>() &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    db.<span class="hljs-built_in">close</span>();<br>  &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span>(...)&#123;<br>    ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>The two solutions above have a disadvantage. The program has not opportunity to react to the problems that may arise.<br />
A better strategy is shown as below</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DBConn</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>      db.<span class="hljs-built_in">close</span>();<br>      closed = <span class="hljs-literal">true</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">DBConn</span>() &#123;<br>      <span class="hljs-keyword">if</span> (!closed) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          db.<span class="hljs-built_in">close</span>();<br>        &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span>(...) &#123;...&#125;<br>      &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="never-call-virtual-functions-during-construction-or-desctuction"><a class="markdownIt-Anchor" href="#never-call-virtual-functions-during-construction-or-desctuction"></a> Never call virtual functions during construction or desctuction</h1>
<p>Let’s see the code below</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Transaction</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Transaction</span>() &#123;<br>      <span class="hljs-built_in">logTransaction</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuyTransaction</span>:</span> <span class="hljs-keyword">public</span> Transaction &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SellTransaction</span>:</span> <span class="hljs-keyword">public</span> Transaction &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>When you create a derived class object, the base class constructor will be call before the derived clss constructor. If you call virtual fucntions in the base class constructor, it will not call the derived class version, because derived class data members have not been initialized.</p>
<p>Actually, during base class constructor of a derived class object, the type of the object is that of the base class.</p>
<p>The same reasoning applies during destruction.</p>
<p>The solution is that to turn logTransaction into a non-virutal function, then require that derived class constructors pass the necessary log information to the Transaction constructor.</p>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Transaction</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Transaction</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string&amp; logInfo)</span> </span>&#123;<br>     <span class="hljs-built_in">logTransaction</span>(logInfo);<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std;:string&amp; logInfo)</span> <span class="hljs-keyword">const</span></span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuyTransaction</span>:</span> <span class="hljs-keyword">public</span> Transaction &#123;<br>  <span class="hljs-keyword">public</span>:<br>   <span class="hljs-built_in">BuyTransaction</span>(parameters):<span class="hljs-built_in">Transaction</span>(<span class="hljs-built_in">createLogString</span>(parameters)) &#123;...&#125;<br>  <span class="hljs-keyword">private</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">static</span> std::string <span class="hljs-title">createLogString</span><span class="hljs-params">(parameters)</span></span>;  <span class="hljs-comment">// make the functions static in case of referring to uninitialized datamembers.</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="have-assignment-operators-return-a-reference-to-this"><a class="markdownIt-Anchor" href="#have-assignment-operators-return-a-reference-to-this"></a> Have assignment operators return a reference to *this.</h1>
<p>C++ supports chain of assignments and the assignment is right-associative.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> x, y, z;<br>x = y = z = <span class="hljs-number">15</span>;  <span class="hljs-comment">// equal to x = (y = (z = 15))</span><br></code></pre></td></tr></table></figure>
<p>The assignment returns a reference to its left-hand argument.</p>
<p>When you implement assignment operators for your classes, you should follow the convention.</p>
<h1 id="handle-assignment-to-self-in-operator"><a class="markdownIt-Anchor" href="#handle-assignment-to-self-in-operator"></a> Handle assignment to self in operator=</h1>
<p>When you implement a operator= in a class, it may occurs self-assignment and this will cause some problem. For example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bitmap</span>&#123;</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Widget&amp; rhs) &#123;<br>      <span class="hljs-keyword">delete</span> pb;  <span class="hljs-comment">// if *this and rhs is same object, a problem occur.</span><br>      pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);<br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>  <span class="hljs-keyword">private</span>:<br>    Bitmap *pb;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>The traditional way to prevent this error is to check for assignment to self via an identity test at the top of operator=</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Widget&amp; rhs) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs)<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span><br>  <span class="hljs-keyword">delete</span> pb;<br>  pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>The scheme above can avoid self-assignment, but it was exception-unsafe. If the “new Bitmap” expression yields an exception, the Widget will hold a pointer to a deleted Bitmap.</p>
<p>A exception-safe and assignment-safe solution is shown also below</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Widget&amp; rhs) &#123;<br>  Bigmap *pOrig = pb;<br>  pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);<br>  <span class="hljs-keyword">delete</span> pOrig;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>A alternative to solution is use the technique know as “copy and swap”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; rhs)</span></span>;  <span class="hljs-comment">// exchange rhs&#x27;s data and *this&#x27;s data.</span><br>    Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Widget&amp; rhs) &#123;<br>      Widget <span class="hljs-built_in">temp</span>(rhs);<br>      <span class="hljs-built_in">swap</span>(temp)<br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-comment">// another way</span><br>    Widget&amp; <span class="hljs-keyword">operator</span>=(Widget rhs) &#123;  <span class="hljs-comment">// this will create a copy of rhs.</span><br>      <span class="hljs-built_in">swap</span>(temp);<br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="copy-all-parts-of-an-object"><a class="markdownIt-Anchor" href="#copy-all-parts-of-an-object"></a> Copy all parts of an object</h1>
<p>Copying functions should be sure to copy all of an object’s data members and all of its base class parts.</p>
<p>Don’t try to implement one of the copying functions in terms of the other. Instead, put common functionality in a third function that both call.</p>
<h1 id="use-objects-to-manage-resources"><a class="markdownIt-Anchor" href="#use-objects-to-manage-resources"></a> Use objects to manage resources</h1>
<p>There are two critical aspects of using objects to manager resources</p>
<ul>
<li>Resources are acquired and immediately turned over to resource-managing objects.</li>
<li>Resource-managing objects use their destructors to ensure that resources are released.</li>
</ul>
<p>This item suggests that if you’re releasing resources manually, you’re doing something wrong.</p>
<h1 id="think-carefully-about-copying-behavior-in-resource-managing-classes"><a class="markdownIt-Anchor" href="#think-carefully-about-copying-behavior-in-resource-managing-classes"></a> Think carefully about copying behavior in resource-managing classes</h1>
<p>There are some copying behaviors as below</p>
<ol>
<li>Prohibit copying</li>
<li>Reference-count the underlying resource</li>
<li>Copy the underlying resource</li>
<li>Transfer ownership of the underlying resouce</li>
</ol>
<p>So the copying function behavior should depend on what you want.</p>
<h1 id="provide-access-to-raw-resources-in-resource-managing-classes"><a class="markdownIt-Anchor" href="#provide-access-to-raw-resources-in-resource-managing-classes"></a> Provide access to raw resources in resource-managing classes.</h1>
<p>When you use classes to manage resources, you should access the resources with resource-managing classes, never sullying your hands with direct access to raw resources. But many APIs refer to access to raw resources. So you should provide a way to convert object into the raw resource it contains in resource-managing classes.</p>
<p>There two general ways to do it: explicit conversion and implicit conversion.</p>
<ol>
<li>explicit conversion means that you should offer a get member function to return the raw pointer. But everytime you want to use raw resource, you must requset the get function. That in turn, would increase the chances of leaking fronts.</li>
<li>implicit conversion function is shown as below<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Font</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">FontHandle</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;reutrn f;&#125;  <span class="hljs-comment">//implicit conversion function</span><br>&#125;<br></code></pre></td></tr></table></figure>
The downside is that implicit conversions increase the chance of error. For example<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Font <span class="hljs-title">f1</span><span class="hljs-params">(getFont())</span></span>;<br><br>FontHandle f2 = f1;  <span class="hljs-comment">// f2 can access f1&#x27;s resource. When f1 is destroyed, f2 will dangle.</span><br></code></pre></td></tr></table></figure>
The decision about to offer explicit conversion or to offer implicit conversion is one that depends on the situation.<br />
explicit conversion is safer, but implicit conversion is more convenient for client. It is a tradeoff.</li>
</ol>
<h1 id="use-the-same-form-in-corresponding-uses-of-new-and-delete"><a class="markdownIt-Anchor" href="#use-the-same-form-in-corresponding-uses-of-new-and-delete"></a> Use the same form in corresponding uses of new and delete</h1>
<p>When employing a new expression, two things happen.</p>
<ol>
<li>allocate memory</li>
<li>call one or more constructors for that memory</li>
</ol>
<p>The same as empolying a delete express</p>
<ol>
<li>one or more destructors are called.</li>
<li>the memory is deallocated.</li>
</ol>
<p>If you use [] in a new expression, you must use [] in the corresponding delete expression. If you don’t use [] in a new expression, you mustn’t use [] in the corresponding delete expression.</p>
<h1 id="store-newed-objects-in-smart-pointers-in-standalone-statements"><a class="markdownIt-Anchor" href="#store-newed-objects-in-smart-pointers-in-standalone-statements"></a> Store newed objects in smart pointers in standalone statements</h1>
<p>Consider a function call as below</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">processWidget</span>(std::shared_ptr&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget), <span class="hljs-built_in">priority</span>());<br></code></pre></td></tr></table></figure>
<p>Before calling processWidget, compiler has to evaluate the arguments being passed as its parameters. In this cases, compiler has three things to do</p>
<ol>
<li>Call priority</li>
<li>Execute new Widget</li>
<li>Call shared_ptr constructor.</li>
</ol>
<p>In C++, compilers are granted considerable latitude in determining the order in which these things are to be done.</p>
<p>Consider a sequence of operations as below</p>
<ol>
<li>Execute new Widget</li>
<li>Call priority</li>
<li>Call shared_ptr constructor</li>
</ol>
<p>If priority function yields an exception, the pointer returned from new Widget will be lost.</p>
<p>The way to avoid problems is simple: use a separate statement to create the Widget and store in a smart pointer.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">pw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span>;<br><span class="hljs-built_in">processWidget</span>(pw, priority)<br></code></pre></td></tr></table></figure>
<h1 id="make-interface-easy-to-use-correctly-and-hard-to-use-incorrectly"><a class="markdownIt-Anchor" href="#make-interface-easy-to-use-correctly-and-hard-to-use-incorrectly"></a> Make interface easy to use correctly and hard to use incorrectly</h1>
<p>Good interfaces are easy to use correctly and hard to use incorrectly. You should strive for these characteristics in all your interfaces.</p>
<p>Ways to facilitate correct use include consistency in interfaces and behavioral compatibility with build-in types</p>
<p>Ways to prevent errors include creating new types, restricting operations on types, constraining object values, and eliminating client resource management responsibilites.</p>
<h1 id="treat-class-design-as-type-design"><a class="markdownIt-Anchor" href="#treat-class-design-as-type-design"></a> Treat class design as type design</h1>
<p>Class design is type design. You should answer the questions below</p>
<ul>
<li>How should objects of your new type be created and destroyed? About how to design class’s constructors and destructor.</li>
<li>How should object initialization differ from object assignment? About how to design copy constructor and assignment operator.</li>
<li>What does it mean for objects of your new type to be passed by value? About copy constructor.</li>
<li>What are the restrictions on legal values for your new type. About value check.</li>
<li>Does your new type fit into an inheritance graph? inheritance function, virtual or non-virtual.</li>
<li>What kind of type conversions are allowed for your new type? conversion function design.</li>
<li>What operators and functions make sense for the new type?</li>
<li>What standard functions should be disallowed? which function is private.</li>
<li>Who shoud have access to members of your new type? public, protect or private member.</li>
<li>What is the “undeclared interface” of your new type?</li>
<li>How general is your new type</li>
<li>Is a new type really what you need.</li>
</ul>
<h1 id="prefer-pass-by-reference-to-const-to-pass-by-value"><a class="markdownIt-Anchor" href="#prefer-pass-by-reference-to-const-to-pass-by-value"></a> Prefer pass-by-reference-to-const to pass-by-value</h1>
<p>For build-in types, it’s often more efficient to pass it by value than by reference.</p>
<p>For iterators and function objects in STL, pass by value is more efficient too, because they are designed to be passed by value.</p>
<p>For other types, pass by reference is a better choice. It’s typically more efficient and it avoid the slicing problem.</p>
<h1 id="dott-try-to-return-a-reference-when-you-must-return-an-object"><a class="markdownIt-Anchor" href="#dott-try-to-return-a-reference-when-you-must-return-an-object"></a> Dot’t try to return a reference when you must return an object</h1>
<p>Reference just a name for some existing object.</p>
<p>Never return a pointer or reference to a local stack object, a reference to a heap-allocated object, or a pointer or reference to a local static object if there is a chance that more one such object will be need.</p>
<h1 id="declare-data-members-private"><a class="markdownIt-Anchor" href="#declare-data-members-private"></a> Declare data members private</h1>
<p>Making a data member private can implement more precise control of the accessibility. For example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessLevels</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getReadOnly</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> readOnly;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setReadWrite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;readWrite=value;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getReadWrite</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> readWrite;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setWriteOnly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;writeOnly = value;&#125;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> noAccess;<br>    <span class="hljs-keyword">int</span> readOnly;<br>    <span class="hljs-keyword">int</span> readWrite;<br>    <span class="hljs-keyword">int</span> writeOnly;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>Making a data member private can offer more flexibility. If a data member is public, when your ability to change it is extremely restricted, because too much code will be broken.</p>
<p>Public means unencapsulated, and unencapsulated means unchangeable.</p>
<p>For short getter and setter, you can declare them inline for speed up.</p>
<h1 id="prefer-non-member-non-friend-functions-to-member-functions"><a class="markdownIt-Anchor" href="#prefer-non-member-non-friend-functions-to-member-functions"></a> Prefer non-member non-friend functions to member functions</h1>
<p>Object-oriented principles dictate that data should be as encapsulated as possible.</p>
<p>See the example below</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebBrowser</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearCache</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearHistory</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeCookies</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>Many users will want to perform all these actions together. There are two implementation</p>
<ol>
<li>add a new member function<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebBrowser</span> &#123;</span><br>  publc:<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearEverything</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li>add a non-member function<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearBrowser</span><span class="hljs-params">(WebBrowser&amp; wb)</span> </span>&#123;<br>  wb.<span class="hljs-built_in">clearCache</span>();<br>  wb.<span class="hljs-built_in">clearHistory</span>();<br>  wb.<span class="hljs-built_in">removeCookier</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>The better implementation is second. Because member function yields less encapsulation than the non-member function.<br />
The reason is shown as below.</p>
<p>The more something is encapsulated, the fewer things can see it. The fewer things can see it, the greater flexibility we have to change it.</p>
<p>As a coarse-grained measure of how much code can see a piece of data, we can count the number of functions that can access that data. The more functions that can access it, the less encapsulated the data.</p>
<p>Thus, the member functions or the friend functions will yields less encapsulation.</p>
<p>In C++, a more natural approach would be to make clearBrowser a non-member function in the same namespace as WebBrowser.</p>
<p>A class like WebBrowser might have a large number of convenience functions, some related to bookmarks, others related to printing, etc. Most client will be interested in only a small sets of convenience functions. A practial is that declare bookmark-related convenience functsion in one header file, cookie-related convenience functions in a different headerf file, etc.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// header webbrowser.h</span><br><span class="hljs-keyword">namespace</span> WebBrowserStuff &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebBrowser</span>&#123;</span>&#125;;<br>&#125;<br><span class="hljs-comment">// header webbrowserbookmarks.h</span><br><span class="hljs-keyword">namespace</span> WebBrowserStuff &#123;<br>  <span class="hljs-comment">// some bookmark-related convenience functions</span><br>&#125;<br><span class="hljs-comment">//header webbrowsercookies.h</span><br><span class="hljs-keyword">namespace</span> WebBrowserSTuff &#123;<br>  <span class="hljs-comment">// some cookie-related convenience functions</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="declare-non-member-functions-when-type-conversions-should-apply-to-all-parameters"><a class="markdownIt-Anchor" href="#declare-non-member-functions-when-type-conversions-should-apply-to-all-parameters"></a> Declare non-member functions when type conversions should apply to all parameters</h1>
<p>Considering a Rational class, you’d like to support arithmetic operations. It is natural to implement operator* inside the Ration class.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rational</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rational</span>(<span class="hljs-keyword">int</span> numerator=<span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> denominator=<span class="hljs-number">1</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numerator</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">denominator</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><br>    <span class="hljs-keyword">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> Rational &amp;rhs) <span class="hljs-keyword">const</span>;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> numerator, denominator;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>But when you try to do mixed-mode arthmetic, there is a problem</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Rational <span class="hljs-title">oneHalf</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>Rational result;<br>result = oneHalf * <span class="hljs-number">2</span>;  <span class="hljs-comment">// pass</span><br>result = <span class="hljs-number">2</span> * oneHalf;  <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure>
<p>The first one successes because the compiler call a non-expllicit constructor to create a temporary Rational object from 2.</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const Rational temp(<span class="hljs-number">2</span>)<span class="hljs-comment">;</span><br>result oneHalf * temp<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
<p>If you’d like to support mixed-mode arithmetic, you should make operator* a non-member function, thus allowing compilers to perform implict type conversions on all arguments.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rational</span> &#123;</span>...&#125;;<br><br><span class="hljs-keyword">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> Rational&amp; lhs, <span class="hljs-keyword">const</span> Rational&amp; rhs) &#123;...&#125;<br><br><span class="hljs-function">Rational <span class="hljs-title">oneFourth</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)</span></span>;<br>Rational result;<br>result = oneFourth * <span class="hljs-number">2</span>;  <span class="hljs-comment">// pass</span><br>result = <span class="hljs-number">2</span> * oneFourth;  <span class="hljs-comment">// pass</span><br></code></pre></td></tr></table></figure>
<p>The sequence of such operator functions is, member function, non-member functions(at namespace or global scope)</p>
<h1 id="consider-support-for-a-non-throwing-swap"><a class="markdownIt-Anchor" href="#consider-support-for-a-non-throwing-swap"></a> Consider support for a non-throwing swap</h1>
<p>The default swap algorithm implementation is shown as below</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">  <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span> </span>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">temp</span><span class="hljs-params">(a)</span></span>;  <span class="hljs-comment">//class should implement copy constructor and copy assignment operator</span><br>    a = b;<br>    b = temp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>In the default swap implementation, it involves copying three objects. However, for some types, it is expensive. For example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WidgetImpl</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> a, b, c;<br>    std::vector&lt;<span class="hljs-keyword">double</span>&gt; v;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br><br>  <span class="hljs-keyword">private</span>:<br>    WidgetImpl *pImpl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>To swap the value of two Widget objects, we just need to swap their pImpl pointers instead of copying three objects.</p>
<p>If we want default swap algorithm to swap internal pImpl pointers, what we need to do is specialized std::swap function for Widget.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std&#123;<br>  <span class="hljs-keyword">template</span>&lt;&gt;<br>  <span class="hljs-keyword">void</span> swap&lt;Widget&gt;(Widget &amp;a, Widget &amp;b) &#123;<br>    <span class="hljs-built_in">swap</span>(a.pImpl, b.pImpl);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>The function above has a small problem, because the pImple is private member for Widget class.<br />
To solution this problem is simple: declare a public member function called swap that do actual swapping, the specialize std::swap to call the member function.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget &amp;other)</span> </span>&#123;<br>      <span class="hljs-keyword">using</span> std::swap;<br>      <span class="hljs-built_in">swap</span>(pImpl, other.pImpl);<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">namespace</span> std &#123;<br>  <span class="hljs-keyword">template</span>&lt;&gt;<br>  <span class="hljs-keyword">void</span> swap&lt;Widget&gt;(Widget &amp;a, Widget &amp;b) &#123;<br>    a.<span class="hljs-built_in">swap</span>(b);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>This will work because std allow total template specialization.</p>
<p>But when class Widget and WidgetImpl is template, the scheme above does not work, because C++ doesn’t allow partially specialize for function templates. If you want to partially specialize a function template, the usual approach is to simply add an overload, such as</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">  <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&lt;T&gt; &amp;a, Widget&lt;T&gt; &amp;b)</span> </span>&#123;<br>    a.<span class="hljs-built_in">swap</span>(b);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>But std is a special namespace. We can totally specialize template in std, but it doesn’t allow to add new tempaltes to std.</p>
<p>The answer is that we still declare a non-member swap that call the member swap instead of declaring a non-member to be a specialization or overloading of std::swap</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> WidgetStuff &#123;<br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>&#123;</span>&#125;;<br><br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">  <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&lt;T&gt; &amp;a, Widget&lt;T&gt; &amp;b)</span> </span>&#123;<br>    a.<span class="hljs-built_in">swap</span>(b);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>If any code calls swap on two Widget objects, the name lookup rules in C++ will find the Widget-specific version in WidgetStuff.</p>
<p>In summary, we need to write both a non-member version in the same namespace as your class and specialization of std::swap.</p>
<p>In the client’s view, we do not know that a specialization of the general one or a T-specific one may or may not exist. The better way is shown as below</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(T &amp;obj1, T &amp;obj2)</span> </span>&#123;<br>  <span class="hljs-keyword">using</span> std::swap;  <span class="hljs-comment">// make std::swap available</span><br><br>  <span class="hljs-built_in">swap</span>(obj1, obj2);  <span class="hljs-comment">// make the compiler to choose the best swap.</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>C++'s name lookup rules is that compiler will find any T-specific swap at global scope or in the same namespace as the type T. If no T-specific swap exists, compilers will use swap in std. If std::swap has been specialized for T, the compiler will prefer a T-specific specialization of std::swap.</p>
<ol>
<li>If the defulat implementation of swap is ok, you don’t need to do anything.</li>
<li>Otherwise, do the following things
<ol>
<li>Offer a public swap member function. This function should never throw an exception.</li>
<li>Offer a non-member swap in the same namespace as you class or template.</li>
<li>If writing a class, specialize std::swap for this class.</li>
</ol>
</li>
<li>when calling swap, be sure to include a suing declaration to make std::swap visible in function, then call swap without any namespace qualification.</li>
</ol>
<h1 id="postpone-variable-definitions-as-long-as-possible"><a class="markdownIt-Anchor" href="#postpone-variable-definitions-as-long-as-possible"></a> Postpone variable definitions as long as possible</h1>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::string <span class="hljs-title">encryptPassword</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string&amp; password)</span> </span>&#123;<br>  <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>  string encrypted;<br>  <span class="hljs-keyword">if</span> (password.<span class="hljs-built_in">length</span>() &lt; MinimumPasswordLength) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;Password is too short&quot;</span>);<br>  &#125;<br>  ...<br>  <span class="hljs-keyword">return</span> encrypted;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>In the code above, if an exception is thrown, the object encrypted isn’t unused. it is better to postponing encrypted’s definition until it is needed.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::string <span class="hljs-title">encryptPassword</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string&amp; password)</span> </span>&#123;<br>  ...<br>  <span class="hljs-function">string <span class="hljs-title">encrypted</span><span class="hljs-params">(password)</span></span>;<br>  <span class="hljs-built_in">encrypt</span>(encrypted);<br>  <span class="hljs-keyword">return</span> encrypted;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>If a variable is used only inside a loop, there are two approach</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Approach A: define outside loop</span><br><span class="hljs-function">Widget w</span><br><span class="hljs-function"><span class="hljs-title">for</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)</span> </span>&#123;<br>  w = ...<br>&#125;<br><span class="hljs-comment">// Approach B: define inside loop</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>  Widget <span class="hljs-built_in">w</span>(...);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>The cost of these two approaches are as follow</p>
<ul>
<li>Approach A: 1 constructor + 1 destructor + n assignments</li>
<li>Approach B: n constructors + n destructors</li>
</ul>
<p>If an assignment costs less than a constructor-desctructor pair, Approach A is more efficient as n growing larger. Otherwise B is better.</p>
<h1 id="minimize-casting"><a class="markdownIt-Anchor" href="#minimize-casting"></a> Minimize casting</h1>
<p>C++ offers four new cast forms</p>
<ul>
<li>const_cast<T>(), only way to remove the constness of objects.</li>
<li>dynamic_cast<T>(), used to perform safe downcasting. Only way that cannot be performed using the old-style syntax. Only way that may have a significant runtime cost.</li>
<li>reinterpret_cast<T>(), intended for low-level casts, such as casting a pointer to int.</li>
<li>static_cast<T>(), used to force implicit conversions.</li>
</ul>
<p>C++ also support C-style casts, such as (T) expression and T(expression). But new forms are preferable.</p>
<ol>
<li>mush easier to indentify in code.</li>
<li>compiler can diagnose usage error.</li>
</ol>
<p>Type conversions often lead to code that is executed at runtime.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>&#123;</span>...&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span>:</span> <span class="hljs-keyword">public</span> Base &#123;...&#125;;<br>Derived d;<br>Base *bp = &amp;d;<br></code></pre></td></tr></table></figure>
<p>In the code above, the base class pointer and the derived class pointer will not be the same. An offset is applied at runtime to the derived pointer to get the correct base pointer value.</p>
<p>The offset varies from compiler to compiler. So, you should generally avoid making assumptions about how things are laid out in C++, and you should certainly not perform casts based on such assumptions.</p>
<p>Suppose we want the virtual member function in derived classes call their base class couterparts first.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Window</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResize</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpecialWindow</span>:</span> <span class="hljs-keyword">public</span> Window &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResize</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">static_cast</span>&lt;Window&gt;(*<span class="hljs-keyword">this</span>).<span class="hljs-built_in">onResize</span>();<br>      ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>The implementation in the code is wrong, because cast will create a new, temporary copy of the base class part of *this, then invokes onResize on the copy.</p>
<p>The correct way to implement what you expect is shown as below</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Window</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResize</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpecialWindow</span>:</span> <span class="hljs-keyword">public</span> Window &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResize</span><span class="hljs-params">()</span> </span>&#123;<br>      Window::<span class="hljs-built_in">onResize</span>();<br>      ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>The dynamic_cast generally cast base class pointer or reference to what you believe to be a derived class object.</p>
<p>A common implementation is based in part on string comparisons of class names. So the dyname_cast cost is expensive.</p>
<p>Avoid casts whenever practical, especially dynamic_casts in performance-sensitive code. If requires casting, try to develop a cast-free alternative.</p>
<p>When casting is necessary, try to hide it inside a function.</p>
<h1 id="avoid-returning-handles-to-object-internals"><a class="markdownIt-Anchor" href="#avoid-returning-handles-to-object-internals"></a> Avoid returning handles to object internals.</h1>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Point</span>(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y);<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setX</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newVal)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setY</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newVal)</span></span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RectData</span> &#123;</span><br>  Point ulhc;<br>  Point lrhc;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// according to perfer pass-by-reference-to-const to pass-by-value, return reference is more efficient.</span><br>    <span class="hljs-function">Point&amp; <span class="hljs-title">upperLeft</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> pData-&gt;ulhc;&#125;<br>    <span class="hljs-function">Point&amp; <span class="hljs-title">lowerRight</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> pData-&gt;lrhc;&#125;<br>  <span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;RectData&gt; pData;<br>&#125;;<br><span class="hljs-function">Point <span class="hljs-title">coord1</span><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function">Point <span class="hljs-title">coord2</span><span class="hljs-params">(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">const</span> Rectangle <span class="hljs-title">rec</span><span class="hljs-params">(coord1, coord2)</span></span>;<br>rec.<span class="hljs-built_in">uperLeft</span>().<span class="hljs-built_in">setX</span>(<span class="hljs-number">50</span>);  <span class="hljs-comment">// pass</span><br></code></pre></td></tr></table></figure>
<p>In the example above, rec is declared as const, but we can modify its internal Point data member. This is what we won’t.</p>
<p>Returning pointers or iterators will cause the same problem.</p>
<p>References, pointers and iterators are all handles, and returning a handle to an object’s interals always runs the risk of compromising an object’s encapsulation.</p>
<p>We could applying const to their return types to avoid modifying.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">const</span> Point&amp; <span class="hljs-title">upperLeft</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> pData-&gt;ulhc;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">const</span> Point&amp; <span class="hljs-title">lowerRight</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> pData-&gt;lrhc;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>But it can be problematic in other ways. It can lead to dangling handles.</p>
<p>Avoid returning handles (references, pointers, or iterators) to object internals. Not returning handles increases encapsulation, helps const member functions act const , and minimizes the creation of dangling handles.</p>
<h1 id="strive-for-exception-safe-code"><a class="markdownIt-Anchor" href="#strive-for-exception-safe-code"></a> Strive for exception-safe code</h1>
<p>When an exception is thrown, there are two requirements for exception safety.</p>
<ul>
<li>Leak no resource.</li>
<li>Don’t allow data structures to become corrupted.</li>
</ul>
<p>Exception-safe functions must offer one of three guarantees</p>
<ul>
<li>The base guarantee promise. If an exception is thrown, everything in the program remains in a valid state. No objects or data structures become corrupted, and all objects are in internally consistent state. But the exact state of program may not be predictable.</li>
<li>The strong guarantee promise. If an exception is thrown, the state of the program is unchanged.</li>
<li>The nothrow guarantee promise. Never to throw exception. All operations on build-in types are nothrow.</li>
</ul>
<p>We can not distinguish the guarantee from the declaration of a function. All those guarantee are determined by the function’s implmentation, not its declaration.</p>
<p>There is a general design strategy that typically leads to the strong guarantee. The strategy is known as copy and swap.<br />
Make a copy of the object you want to modify, then make all needed changes to the copy. After all the changes have been successfully completed, swap the modified object with the original in a non-throwing operation.</p>
<p>The copy-and-swap strategy has some disadvantage</p>
<ul>
<li>it doesn’t guarantee that the overall function is strongly exception-safe. Consider a function throw a exception after a database modify function call. The database state will change and can not undo.</li>
<li>copying object may be expensive.</li>
</ul>
<p>A function can usually offer a guarante no stronger that the weakest guarantee of the functions it calls.</p>
<h1 id="understand-the-ins-and-outs-of-inlining"><a class="markdownIt-Anchor" href="#understand-the-ins-and-outs-of-inlining"></a> Understand the ins and outs of inlining</h1>
<p>The idea behind an inline function is to replace each call of that function with its code body. In general, overzealous inlining may increase program size. But if an inline function body is very short, the code generated for the function body may be smaller than the code generated for a function call.</p>
<p>Inline is a request to compiler, not a command. So the compiler will decide if inlining the function will lead to any benefits.<br />
The requset can be given implicitly or explicitly.</p>
<ul>
<li>implicitly: define a function inside a class definition.</li>
<li>explicitly: use inline keyword.</li>
</ul>
<p>Inline function must typically be in header files, because most build environments do inlining during compilation.</p>
<p>Limit most inlining to small, frequently called functions.</p>
<h1 id="minimize-compilation-dependencies-between-files"><a class="markdownIt-Anchor" href="#minimize-compilation-dependencies-between-files"></a> Minimize compilation dependencies between files</h1>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">const</span> std::string&amp; name, <span class="hljs-keyword">const</span> Date&amp; birthday, <span class="hljs-keyword">const</span> Address&amp; addr);<br>    <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-function">std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-function">std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>  <span class="hljs-keyword">private</span>:<br>    std::string theName;<br>    Date theBirthDate;<br>    Address theAddress;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>Look at the code above. If any header file used in Person class changed, the Person class must be recompiled, as must any files that use Person.</p>
<p>The compiler must know the Person size to allocate enough space. The only way to calculate the size it to consult the class definition.</p>
<p>A solution is shown as below</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonImpl</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Date</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-keyword">const</span> std::string&amp; name, <span class="hljs-keyword">const</span> Date&amp; birthday, <span class="hljs-keyword">const</span> Address&amp; addr);<br>    <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-function">std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-function">std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>  <span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;PersonImpl&gt; pImpl;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>The clients of Person are divorced from the details of dates, addresses and persons. In the code above, the client uses Person clas instead of PersonImpl class, only Person class uses PersonImpl class.</p>
<p>The key is replacement of dependencie on definitions with dependencies on declarations. Make your header files self-sufficient whenever it’s practical and when it’s not depend on declarations in other files, not definitions.</p>
<ul>
<li>Avoid using objects when object references and pointers will do.</li>
<li>Depend on class declarations instead of class definitions whenever you can.</li>
<li>Provide separate header files for declarations and definitions.</li>
</ul>
<p>I didn’t fully understand this item.</p>
<h1 id="make-sure-public-inheritance-models-is-a"><a class="markdownIt-Anchor" href="#make-sure-public-inheritance-models-is-a"></a> Make sure public inheritance models “is-a”</h1>
<p>Public inheritance means “is-a”. Everything that applies to base classes must also apply to derived classes.</p>
<h1 id="avoid-hiding-inherited-names"><a class="markdownIt-Anchor" href="#avoid-hiding-inherited-names"></a> Avoid hiding inherited names.</h1>
<p>When a class inherits a base class, the deried class inherits the things declared in the base class. Actually, the scope of the derived class is nested inside its base class’s scope.</p>
<p>The names in the inner scopes hide names in outer scopes. C++'s name-hiding rules do just that: hind names. Whether the names correspond to the same or different types is immaterial.</p>
<p>For example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> x;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf2</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">(<span class="hljs-keyword">double</span>)</span></span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span>:</span> <span class="hljs-keyword">public</span> Base &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mf4</span><span class="hljs-params">()</span></span>;<br>&#125;;<br>Derived d;<br><span class="hljs-keyword">int</span> x;<br>d.<span class="hljs-built_in">mf1</span>();  <span class="hljs-comment">// call Derived::mf1</span><br>d.<span class="hljs-built_in">mf1</span>(x); <span class="hljs-comment">// error Derived::mf1 hides Base::mf2</span><br>d.<span class="hljs-built_in">mf2</span>();  <span class="hljs-comment">// call Based::mf2</span><br>d.<span class="hljs-built_in">mf3</span>();  <span class="hljs-comment">// call Derived::mf3</span><br>d.<span class="hljs-built_in">mf3</span>(x); <span class="hljs-comment">// error </span><br></code></pre></td></tr></table></figure>
<p>name-hiding rule will applies regardless of whether the functions are virtual or non-virtual or the functions take different parameter types.</p>
<p>The solution is to do it with using declarations</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> x;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf2</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">(<span class="hljs-keyword">double</span>)</span></span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span>:</span> <span class="hljs-keyword">public</span> Base &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Base::mf1;  <span class="hljs-comment">// make mf1 and mf3 in Base class visible in Derived&#x27;s scope</span><br>    <span class="hljs-keyword">using</span> Base::mf3;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mf4</span><span class="hljs-params">()</span></span>;<br>&#125;;<br>Derived d;<br><span class="hljs-keyword">int</span> x;<br>d.<span class="hljs-built_in">mf1</span>(x); <span class="hljs-comment">// call Base::mf1 </span><br>d.<span class="hljs-built_in">mf3</span>(x); <span class="hljs-comment">// call Base::mf3 </span><br></code></pre></td></tr></table></figure>
<p>Something you won’t want to inherit all the functions from base class. The correct way to do is shown as below</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span>:</span> <span class="hljs-keyword">public</span> Base &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> </span>&#123;Base::<span class="hljs-built_in">mf1</span>();&#125;<br>&#125;;<br>Derived d;<br><span class="hljs-keyword">int</span> x;<br>d.<span class="hljs-built_in">mf1</span>(); <span class="hljs-comment">// call Base::mf1 </span><br>d.<span class="hljs-built_in">mf1</span>(x); <span class="hljs-comment">// error </span><br></code></pre></td></tr></table></figure>
<p>When inheritance is combined with templates, it will incur another problem that will tell in other item.</p>
<h1 id="differentiate-between-inheritance-of-interface-and-inheritance-of-implementation"><a class="markdownIt-Anchor" href="#differentiate-between-inheritance-of-interface-and-inheritance-of-implementation"></a> Differentiate between inheritance of interface and inheritance of implementation</h1>
<p>The purpose of declaring a pure virtual function is to have derived classes inherit a function interface only.</p>
<p>It is possible to provide a definition for a pure vitual function, but the only way to call it would e qualify the call with the class name.</p>
<p>The purpose of declaring a simple virtual function is to have derived class inherit a function interface as well as a default implementation.</p>
<p>The purpose of declaring a non-virtual function is to have derived classes inherit a function interface as well as a mandatory implementation.</p>
<p>The differences in declarations for pure virtual, simple virtual, and non-virtual functions allow you to specify with precision what you want derived classes to inherit: interface only, interface and a default implementation, or interface and a mandatory implementation, respectively.</p>
<h1 id="consider-alternatives-to-virtual-functions"><a class="markdownIt-Anchor" href="#consider-alternatives-to-virtual-functions"></a> Consider alternatives to virtual functions.</h1>
<h2 id="non-virtual-interface-idiom"><a class="markdownIt-Anchor" href="#non-virtual-interface-idiom"></a> non-virtual interface idiom</h2>
<p>A form of the Template Method design pattern that wraps public non-virtual member functions around less accessible virtual functions</p>
<h2 id="function-pointer"><a class="markdownIt-Anchor" href="#function-pointer"></a> Function Pointer</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameCharacter</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*HealthCalcFunc)</span><span class="hljs-params">(<span class="hljs-keyword">const</span> GameCharacter&amp;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">GameCharacter</span><span class="hljs-params">(HealthCalcFunc hcf = defaultHealthCalc)</span> : healthFunc(hcf) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-function">reurn <span class="hljs-title">healthFunc</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;&#125;<br>  <span class="hljs-keyword">private</span>:<br>    HealthCalcFunc healthFunc;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>The strategy offers some flexibility</p>
<ul>
<li>Different instances of the same character type can have different health calculation functions.</li>
<li>Health calculation functions for a particular character may be changed at runtime.</li>
</ul>
<h2 id="stdfunction"><a class="markdownIt-Anchor" href="#stdfunction"></a> std::function</h2>
<p>Replace virtual function with std::function data member.</p>
<h2 id="strategy-pattern"><a class="markdownIt-Anchor" href="#strategy-pattern"></a> Strategy pattern</h2>
<p>Replace virtual functions in one hierarchy with virtual functions in another hierarchy.</p>
<p>A disadvantage of moving functionality from a member function to a function outside the class is that the non-member function lacks access to the class’s non-public members.</p>
<h1 id="never-redefine-an-inherited-non-virtual-function"><a class="markdownIt-Anchor" href="#never-redefine-an-inherited-non-virtual-function"></a> Never redefine an inherited non-virtual function</h1>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>&#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">mf2</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span>:</span> <span class="hljs-keyword">public</span> B &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mf2</span><span class="hljs-params">()</span></span>;<br>&#125;;<br>D x;<br>B* pb = &amp;x;<br>D* pd = &amp;x;<br>pb-&gt;<span class="hljs-built_in">mf1</span>();  <span class="hljs-comment">// B::mf1</span><br>pb-&gt;<span class="hljs-built_in">mf2</span>();  <span class="hljs-comment">// D::mf2</span><br>pd-&gt;<span class="hljs-built_in">mf1</span>();  <span class="hljs-comment">// D::mf1</span><br>pd-&gt;<span class="hljs-built_in">mf2</span>();  <span class="hljs-comment">// D::mf2</span><br></code></pre></td></tr></table></figure>
<p>Non-virtual functions are statically bound.<br />
Virtual functions are dynamically bound.</p>
<h1 id="never-redefine-a-functions-inherited-default-parameter-value"><a class="markdownIt-Anchor" href="#never-redefine-a-functions-inherited-default-parameter-value"></a> Never redefine a function’s inherited default parameter value.</h1>
<p>Virtual functions are dynamically bound, but default parameter values are statically bound.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ShapeColor</span>&#123;</span>Red, Green, Blue&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color=Red)</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span>:</span> <span class="hljs-keyword">public</span> Shape &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color=Green)</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br>Shape *pr = <span class="hljs-keyword">new</span> Rectangle;<br>pr-&gt;<span class="hljs-built_in">draw</span>();  <span class="hljs-comment">// call Rectangle::draw(ShapeColor::Red) instead of Rectangle::draw(ShapeColor::Green)</span><br></code></pre></td></tr></table></figure>
<p>The reason of using this strategy is for runtime efficiency. If default parameter values were dynamically bound, compilers would have to come up with a way to determine the appropriate default value for parameters of virtual functions at runtime, which would be slower and more compicated.</p>
<p>But if you follow this rule and also offer default parameter values to users of both base and derived classes, code duplication occurs. If the default parameter value changed in base class, all derived classes that repeat it must also be changed.</p>
<p>In this case, it’s wise to consider alternative designs to virtual functions talking above.</p>
<h1 id="model-has-a-or-is-implemented-in-terms-of-through-composition"><a class="markdownIt-Anchor" href="#model-has-a-or-is-implemented-in-terms-of-through-composition"></a> Model “has-a” or “is-implemented-in-terms-of” through composition</h1>
<p>Composition has meanings completely different from that of public inheritance.</p>
<p>In the application domain, composition means has-a. In the implementation domain, it means is-implemented-in-terms-of.</p>
<h1 id="use-private-inheritance-judiciously"><a class="markdownIt-Anchor" href="#use-private-inheritance-judiciously"></a> Use private inheritance judiciously</h1>
<p>private inheritance has two behavior.</p>
<ul>
<li>Compiler will generally not convert a derived class object into bass class object if the inheritance relationsip between the classes is private.</li>
<li>Members inherited froma private base class become private members of the derived class.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>:</span> <span class="hljs-keyword">private</span> Person&#123;&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Person&amp; p)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Student&amp; s)</span></span>;<br>Person p;<br>Student s;<br><span class="hljs-built_in">eat</span>(p); <span class="hljs-comment">// succeed</span><br><span class="hljs-built_in">eat</span>(s); <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure>
<p>Pirvate inheritance means is-implemented-in-terms-of. If make a class D privately inherit from a class, because you are interested in taking advantage of some of the features available in class B.</p>
<p>Private inheritance is purely an implementation technique.</p>
<p>The choice strategy between private inheritance and composition is that use composition whenever you can, and use private inheritance whenever you must.</p>
<p>One of the case perfer private inheritance over composition is that you’re dealing with a class that has no data in it. Such classes have no non-static data member, no virtual functions, and not virtual base class.</p>
<p>This class conceptually should use no space, but c++ decree that frestanding objects must have non-zero size.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Empty</span> &#123;</span>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HoldsAnInt</span> &#123;</span><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> x;<br>    Empyt e;<br>&#125;;<br><span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(HoldsAnInt) &gt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>)  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p>For most compilers, sizeof(Empty) is 1. But alignment requirements may cause compilers to add padding to class like HoldsAnInt.</p>
<p>This constriant doesn’t apply to base class parts of derived class objects. so</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HoldsAnInt</span>:</span> <span class="hljs-keyword">private</span> Empyt&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> x;<br>&#125;;<br><span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(HoldsAnInt) == <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>
<p>This is known as the empty base optimization(EBO). But the EBO is generally biable only under single inheritance.</p>
<p>Using private inheritance judiciously means empolying it when having considered all the alternatives, it’s the best way to express the relationship between two classes in your software.</p>
<h1 id="use-multiple-inheritance-judiciously"><a class="markdownIt-Anchor" href="#use-multiple-inheritance-judiciously"></a> Use multiple inheritance judiciously</h1>
<p>One of the problem when using multiple inheritance is that it becomes possible to inherit the same name, which will lead to new opportunities for ambiguity.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BorrowableItem</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">checkOut</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElectronicGadget</span> &#123;</span><br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">checkOut</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MP3Player</span> :</span><span class="hljs-keyword">public</span> BorrowableItem, <span class="hljs-keyword">public</span> ElectronicGadget &#123;&#125;;<br>MP3Player mp;<br>mp.<span class="hljs-built_in">checkOut</span>();  <span class="hljs-comment">// ambiguous</span><br></code></pre></td></tr></table></figure>
<p>This ambiguous exist even though only one of the two functions is accessible. Because C++ first indentifies the function that’s the best-match function before seeing whether a function is accessible.</p>
<p>To resolve the ambiguity, must specify which base class’s function to call.</p>
<p>Multiple inheritance can lead to deadly MI diamound.</p>
<p>Classes using virtual inheritance are generally larger than they would be without using virtual inheritance. Access to data members in virtual base classes is also slower than to those in non-virtual base classes.</p>
<p>The rules governing the initialization of virtual base classes are more complicated and less intuitive than are those for non-virtual bases.</p>
<ul>
<li>classes derived from virtual bases that require initialization must be aware of their virtual bases, no matter how far distant the bases are</li>
<li>when a new derived class is added to the hierarchy, it must assume initialization responsibilities for its virtual bases.</li>
</ul>
<p>Advice on virtual base classes</p>
<ul>
<li>don’t use virtual bases unless you need to.</li>
<li>try to avoid putting data in virtual base classes.</li>
</ul>
<p>Multiple inheritance is more complex than single inheritance. It can lead to new ambiguity issues and to the need for virtual inheritance.</p>
<p>Virtual inheritance imposes costs in size, speed, and complexity of initialization and assignment. It’s most practical when virtual base classes have no data.</p>
<p>Multiple inheritance does have legitimate uses. One scenario involves combining public inheritance from an Interface class with private inheritance from a class that helps with implementation.</p>
<h1 id="understand-implicit-interfaces-and-compilet-time-polymorphism"><a class="markdownIt-Anchor" href="#understand-implicit-interfaces-and-compilet-time-polymorphism"></a> Understand implicit interfaces and compilet-time polymorphism.</h1>
<p>The object-oriented programming revolves around explicit interfaces and runtime polymorphism.</p>
<p>The template and generic programming revolves around implicit interface and compile-time polymorphism.</p>
<ol>
<li>Implicit interface is the set of expressions that must be valid in order for the template to compile.</li>
<li>Instantiating templates occurs during compilation.</li>
</ol>
<p>Both classes and templates support interfaces and polymorphism. For classes, interfaces are explicit and centered on function signatures. Polymorphism occurs at the runtime throught virtual functions. For template parameters, interfaces are implicit and based on valid expressions. Polymorphism occurs during compilation throught template instantiation and function overloading resolution.</p>
<h1 id="understand-the-two-meanings-of-typename"><a class="markdownIt-Anchor" href="#understand-the-two-meanings-of-typename"></a> Understand the two meanings of typename</h1>
<p>When declaring template parameters, class and typename are inter-changeable.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//this is not valid C++ code</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print2nd</span><span class="hljs-params">(<span class="hljs-keyword">const</span> C&amp; container)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (container.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-function">C::const_iterator <span class="hljs-title">iter</span><span class="hljs-params">(container.begin())</span></span>;<br>    ++iter;<br>    <span class="hljs-keyword">int</span> value = *iter;<br>    std::cout &lt;&lt; value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Names in a template that are dependent on a template parameter are called dependent names. When a dependent name is nested inside a class, it is a nested dependent name. (What is non-nested dependent name look like?)<br />
In the code above, C::const_iterator is a nested dependent name. More accuratly, it is a type.</p>
<p>Nested dependent names can lead to ambiguity. In the above code, until C is known, there is no way to know whether C::const_iterator is a type or isn’t. So C++ consider a nested dependent name is not a type unless you tell it otherwise.</p>
<p>The correct version of the code above is shown as follow</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print2nd</span><span class="hljs-params">(<span class="hljs-keyword">const</span> C&amp; container)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (container.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">typename</span> C::const_iterator <span class="hljs-title">iter</span><span class="hljs-params">(container.begin())</span></span>;<br>    ++iter;<br>    <span class="hljs-keyword">int</span> value = *iter;<br>    std::cout &lt;&lt; value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>typename should be used to identify only nested dependent type names.</p>
<p>The exception to this rule is that typename must not precede nested dependent type names in a list of base classes or as a base class indentifier in a member initialization list.</p>
<h1 id="know-how-to-access-names-in-templatized-base-classes"><a class="markdownIt-Anchor" href="#know-how-to-access-names-in-templatized-base-classes"></a> Know how to access names in templatized base classes</h1>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgSender</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendClear</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendSecret</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;&#125;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoggingMsgSender</span>:</span> <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt; &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;&#125;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgSender</span>&lt;</span>CompanyZ&gt; &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendSecret</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MsgInfo&amp; info)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>The code above won’t compile. The reason is that when compilers encounter the definition for the class template LoggingMsgSender, they don’t know what class it inherits from. Company is a template parameter, one that won’t be know until later.</p>
<p>Base class templates may be specialized and that such specializations may not offer the same interface as the general template. Thus, compile generally refuses to look in templatized base classes for inherited names.</p>
<p>To solve this problem, we have to somehow disable C++'s “don’t look in templatized base classes” behavior. There are three way to do that</p>
<ol>
<li>Preface calls to base class function with “this-&gt;”.</li>
<li>Employ a using declaration.</li>
<li>Explicitly specify that the function being called in the base class.</li>
</ol>
<p>All of these approaches promise compilers that any subsequent specializations of the base class template will support the interface offered by the general template.</p>
<h1 id="factor-parameter-independent-code-out-of-templates"><a class="markdownIt-Anchor" href="#factor-parameter-independent-code-out-of-templates"></a> Factor parameter-independent code out of templates</h1>
<p>In template code repication is implicit: there’s only one copy of the template source code, so you should sense the replication that may take place when a template is instantiated multiple times.</p>
<p>Templates generate multiple classes and multiple functions, so any template code not dependent on a template parameter causes bloat.</p>
<p>Bloat due to non-type template parameters can often be eliminated by replacing template parameters with function parameters or class data members.</p>
<p>Bloat due to type parameters can be reduced by sharing implementations for instantiation types with identical binary representations.</p>
<h1 id="use-member-function-templates-to-accept-all-compatible-types"><a class="markdownIt-Anchor" href="#use-member-function-templates-to-accept-all-compatible-types"></a> Use member function templates to accept “all compatible types”</h1>
<p>Real pointers supports impicit conversions. Derived class pointers implicitly convert into base class pointers, pointers to non-const objects convert into pointers to const object, etc.</p>
<p>A user-defined smart pointer classes as follow</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmartPtr</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SmartPtr</span><span class="hljs-params">(T *realPtr)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>In the code above, we can’t convert Derived class pointer to base class pointer. For example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Top</span> &#123;</span>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bottom</span>:</span> <span class="hljs-keyword">public</span> Top&#123;&#125;<br>Top *tp = <span class="hljs-keyword">new</span> Bottom; <span class="hljs-comment">// pass</span><br>SmartPtr&lt;Top&gt; stp = SmartPtr&lt;Bottom&gt;(<span class="hljs-keyword">new</span> Bottom); <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure>
<p>Because there is no inherent relationship among different instantiations of the same template.<br />
To achieve conversion that we want, we can write a constructor. However, if the hierarchy is extended in the future, we need to add a new constructor.</p>
<p>Actually, we need a constructor template. Such templates are member function templates.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmartPtr</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function">    <span class="hljs-title">SmartPtr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> SmartPtr&lt;U&gt;&amp; other)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>A small problem in the code above is that a conversion from SmartPtr<Bottom> to SmartPtr<Top> is legal, which is what we want. To restrict the conversion, we can utilize the build-in type implicit conversion.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmartPtr</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function">    <span class="hljs-title">SmartPtr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> SmartPtr&lt;U&gt;&amp; other)</span>:heldPtr(other.get()) &#123;</span>&#125;<br>    <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> heldPtr;&#125;<br>  <span class="hljs-keyword">private</span>:<br>    T *heldPtr;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>This will compile only if there is an implicit conversion from a U* pointer to a T* pointer.</p>
<p>It is not end. Compiler will generate copy constructor and copy opertor function if needed. A important thing is that Declaring a generalized copy constructor in a class doesn’t keep compilers from generating their own copy constructor.</p>
<p>So you must declare both a generalized copy constructo as well as the normal copy constructor.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmartPtr</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SmartPtr</span>(<span class="hljs-keyword">const</span> SmartPtr <span class="hljs-keyword">const</span>&amp; r);<br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function">    <span class="hljs-title">SmartPtr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> SmartPtr&lt;U&gt;&amp; other)</span>:heldPtr(other.get()) &#123;</span>&#125;<br>    <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<span class="hljs-keyword">return</span> heldPtr;&#125;<br>  <span class="hljs-keyword">private</span>:<br>    T *heldPtr;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="define-non-member-functions-inside-templates-when-type-conversions-are-desired"><a class="markdownIt-Anchor" href="#define-non-member-functions-inside-templates-when-type-conversions-are-desired"></a> Define non-member functions inside templates when type conversions are desired</h1>
<p>Implicit type conversion functions are never considered during template argument deduction. Such conversions are used during function calls.</p>
<p>When writing a class template that offers functions related to the template that support implicit type conversions on all parameters, define those functions as friends inside the class template.</p>
<h1 id="use-traits-classes-for-information-about-types"><a class="markdownIt-Anchor" href="#use-traits-classes-for-information-about-types"></a> Use traits classes for information about types</h1>
<p>There are five categories of iterators, C++ has a tag struct for each of the five iterator categories.</p>
<ul>
<li>Input interators, move only forward, move only one step at a time, only read and read only once.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_interator_tag</span>&#123;</span>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li>Output interators, move only forward, move only one step at a time, only write and write only once.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">output_interator_tag</span>&#123;</span>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li>forward interator, conbine input interators and output interator.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">forward_interator_tag</span> :</span> <span class="hljs-keyword">public</span> input_interator_tag&#123;&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li>Bidirectional interators, add to forward interators the ability to move backward as well as forward.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bidirectional_interator_tag</span> :</span> <span class="hljs-keyword">public</span> forward_iterator_tag&#123;&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li>random access iterators, add to bidirectional iterators the ability to jump forward or backward an arbitrary distance in constant time.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">random_access_interator_tag</span> :</span> <span class="hljs-keyword">public</span> bidirectional_interator_tag&#123;&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>Advance moves a specified iterator a specified distance. However, Given the different iterator capabilities, only random access interator can directly achieve iter += d and other interators must be to use a loop that interatively increments or decrements the iterator. The advance’s implementation what we really want is likely like this</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DistT&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">advance</span><span class="hljs-params">(IterT&amp; iter, DistT d)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (iter is a random access iterator) &#123;<br>    iter += d;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (d &gt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">while</span> (d--) &#123;++iter;&#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">while</span>(d++) --iter;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>This requires being able to determine whether iter is a random access iterator, which in turn requires knowing whether its type, IterT, is a random access iterator type… The traits allow you to get information about a type during compilation.</p>
<p>Traits is a technique and a convention followed by C++ programmers. One fo the demands is that it has to work as well for built-in types as it does for user-defined types. It means things like nesting information inside types won’t do.</p>
<p>The standard technique is to put it into a template and one or more specializations of taht template. For interators, the template in the standard library is named iterator_traits</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iterator_traits</span>;</span><br></code></pre></td></tr></table></figure>
<p>The way iterator_traits works is that for each type IterT, a typedef named iterator_category is declared in the struct iterator_traits<IterT>. This typedef identifies the iterator category of IterT. interator_traits implements this in two parts.</p>
<ol>
<li>any user-defined iterator type must contain a nested typedef named iterator_category that identifies the appropriate tag struct.</li>
</ol>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;...&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">deque</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">iterator</span> &#123;</span><br>      <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">typedef</span> random_access_iterator_tag iterator_category;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>iterator_traits just parrots back the iterator class’s nested typedef</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iterator_traits</span> &#123;</span><br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> IterT::iterator_category iterator_category;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>To handle iterators that are pointers. iterato_traits offer a partial tempalte specialization for pointer types. Pointers act as random access iterators</li>
</ol>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iterator_traits</span>&lt;</span>T*&gt; &#123;<br>  <span class="hljs-keyword">typedef</span> random_access_iterator_tag iterator_catagory;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>In summary, To design and implement a traits class</p>
<ol>
<li>Identify some information about types you’d like to make available</li>
<li>Choose a name to identify that information.</li>
<li>Provide a template and set of specializations that contain the information for the types you want to support.</li>
</ol>
<p>Given iterator_traits, we can check the type at the runtime. However, IterT’s type is known during compilation, so we can check at runtime using overload.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DistT&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doAdvance</span><span class="hljs-params">(IterT&amp; iter, DistT d, std::random_access_iterator_tag)</span> </span>&#123;<br>  iter += d;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DistT&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doAdvance</span><span class="hljs-params">(IterT&amp; iter, DistT d, std::bidirectional_iterator_tag)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (d &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">while</span>(d--) ++iter;&#125;<br>  <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">while</span>(d++) --iter;&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DistT&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doAdvance</span><span class="hljs-params">(IterT&amp; iter, DistT d, std::input_iterator_tag)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Negative distance&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">while</span> (d--) ++iter;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>So advance can use overloading resolution to call proper implementation</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DistT&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">advance</span><span class="hljs-params">(IterT &amp;iter, DistT d)</span> </span>&#123;<br>  <span class="hljs-built_in">doAdvance</span>(iter, d, <span class="hljs-keyword">typename</span> std::iterator_traits&lt;IterT&gt;::<span class="hljs-built_in">iterator_category</span>());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>For using a traits class</p>
<ol>
<li>Create a set of overloaded worker functions or function templates that differ in a traits parameter. Implement each function in accord with the traits information passed.</li>
<li>Create a master function or function template that calls the workers, pass information provided by traits class.</li>
</ol>
<h1 id="be-aware-of-template-metaprogramming"><a class="markdownIt-Anchor" href="#be-aware-of-template-metaprogramming"></a> Be aware of template metaprogramming</h1>
<p>Template metaprogramming(TMP) is the process of writing tempalte-based C++ programs that execute during comilation. A template metaprogram is a program written in C++ that executes inside the C++ compiler.</p>
<p>TMP has two great strengths</p>
<ol>
<li>It makes some things easy that would otherwise be hard or impossible.</li>
<li>Can shift work from runtime to compile-time.</li>
</ol>
<p>TMP can accomplish</p>
<ul>
<li>Ensuring dimensional unit correctness.</li>
<li>Optimizing matrix operations.</li>
<li>Generating custom design pattern implementations.</li>
</ul>
<p>The disadvantage of TMP</p>
<ol>
<li>Syntax is unintuitive.</li>
<li>Tool support is weak.</li>
</ol>
<h1 id="understand-the-behavior-of-the-new-handler"><a class="markdownIt-Anchor" href="#understand-the-behavior-of-the-new-handler"></a> Understand the behavior of the new-handler</h1>
<p>Befere operator new throws an exception in response to an unsatisfiable request for memory, it calls a client-specifiable error-handling function called a new-handler. Clients use set_new_handler function specify the out-of-memory-handling function.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*new_handler)</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function">new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(new_handler p)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>throw() means that this function won’t throw any exceptions. set_new_handler function takes a new_handler function pointer and return old function pointer.</p>
<p>A new-handler function must do one of the following</p>
<ul>
<li>Make more memory available. One way to implement this strategy is to allocate a large block of memory at program start-up, then release it for use in the program the first time the new-handler is invoked.</li>
<li>Install a different new-handler.</li>
<li>Deinstall the new-handler. If no new-handler installed, operator new will throw an exception when memeory allocation fails.</li>
<li>Throw an exception. Throw bad_alloc exception or some exception derived from bad_alloc.</li>
<li>Not return. typically by calling abort or exit.</li>
</ul>
<p>Sometimes you’d like to handle memory allocation failures depending on the class of the oject being allocated. The implementation will look like the following</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> std::new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(std::new_handler p)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> std::new_handler currentHandler;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>The set_new_handler function implementation is like the standard version of set_new_handler</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::new_Handler <span class="hljs-title">Widget::set_new_handler</span><span class="hljs-params">(std::new_handler p)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span>&#123;<br>  std::new_handler oldHandler = currentHandler;<br>  currentHandler = p;<br>  <span class="hljs-keyword">return</span> oldHandler;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>The operator new will do the following:</p>
<ol>
<li>Call the standard set_new_handler with Widget’s error-handling function.</li>
<li>Call the global operator new to perform the actual memory allocation. If failed, Widget’s new-handler will be called. Whether exception thrown or not, original new-handler is always reinstated. Thus, treat the global new-handler as a resource and use resource-managing objects to prevent resource leaks.</li>
</ol>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewHandlerHolder</span> &#123;</span><br>    <span class="hljs-keyword">public</span>:<br>      <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">NewHandlerHolder</span><span class="hljs-params">(std::new_handler nh)</span> : handler(nh) &#123;</span>&#125;<br>      ~<span class="hljs-built_in">NewHandlerHolder</span>() &#123;<br>        std::<span class="hljs-built_in">set_new_handler</span>(handler);<br>      &#125;<br>    <span class="hljs-keyword">private</span>:<br>      std::new_handler handler;<br>      <span class="hljs-built_in">NewHandlerHolder</span>(<span class="hljs-keyword">const</span> NewHandlerHolder&amp;);<br>      NewHandlerHolder&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> NewHandlerHolder&amp;);<br>  &#125;<br><span class="hljs-number">3.</span> If allocation successed, <span class="hljs-keyword">return</span> a pointer to the allocated memory. The destructor of resource-managing object will restore the global <span class="hljs-keyword">new</span>-handler.<br><br>The <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span> implementation like <span class="hljs-keyword">this</span><br>```C++<br><span class="hljs-keyword">void</span> * Widget::<span class="hljs-keyword">operator</span> <span class="hljs-built_in"><span class="hljs-keyword">new</span></span>(std::<span class="hljs-keyword">size_t</span> size) <span class="hljs-built_in"><span class="hljs-keyword">throw</span></span>(std::bad_alloc) &#123;<br>  NewHandlerHolder <span class="hljs-built_in">h</span>(std::<span class="hljs-built_in">set_new_handler</span>(currentHandler));<br>  <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in"><span class="hljs-keyword">new</span></span>(size);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>The implementation is class-independent. A better way is to create a template base class. The reason of using template is that each interiting class has its own static data.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewHandlerSupport</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> std::new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(std::new_handler p)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> std::new_handler currentHandler;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>:</span> <span class="hljs-keyword">public</span> NewHandlerSupport&lt;Widget&gt; &#123;&#125;;<br></code></pre></td></tr></table></figure>
<p>C++ required that operator new reutrn null in a early version when it was unable to allocate the requseted memory. Now, operator new will throw a bad_alloc exception. In order to returing null, we can use nothrow</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Widget *pw2 = <span class="hljs-built_in"><span class="hljs-keyword">new</span></span> (std::nothrow) Widget;<br></code></pre></td></tr></table></figure>
<p>If allocation failed, nothrow from will just return null. But if allocation successed, the constructor is called, and if in constructor operator new is called and faild, excpetion will be throw and propagated as usual.</p>
<h1 id="understand-when-it-make-sence-to-replace-new-and-delete"><a class="markdownIt-Anchor" href="#understand-when-it-make-sence-to-replace-new-and-delete"></a> Understand when it make sence to replace new and delete.</h1>
<p>The reason for replacing the compiler-provided version of operator new or operator delete is that</p>
<ul>
<li>To detect usage errors.</li>
<li>To collect usage statistics.</li>
<li>To increase the speed of allocation and deallocation. General-purpose allocators are often a lot slower than custom version. Be sure to profile your program to confim that these functions are turly a bottleneck before custom operator new and operator delete.</li>
<li>To reduce the space overhead of default memory management.</li>
<li>To compensate for suboptimal alignment in the default allocator. Some compilers don’t guarantee eight-byte alignment for dynamic allocations of doubles.</li>
<li>To cluster related objects near one another. Some particular data structures are generally used together and cluster them can minimize the frequency of page faults.</li>
<li>To obtain unconventional behavior. Do something that compiler-provided version don’t offer.</li>
</ul>
<h1 id="adhere-to-convention-when-writing-new-and-delete"><a class="markdownIt-Anchor" href="#adhere-to-convention-when-writing-new-and-delete"></a> Adhere to convention when writing new and delete</h1>
<p>Implementing a conformant operator new requirement</p>
<ul>
<li>Having the right return value. Return a pointer to allocation memory or throw an exception of type bad_alloc.</li>
<li>Calling the new-handling function when insufficient memory is available.</li>
<li>Being prepared to cope with the requests for no memory.</li>
<li>Avoid inadvertently hiding the “normal” form of new.</li>
</ul>
<p>There is no way to get at the new-handling function pointer directly, so you have to call set_new_handler to find out what it is.</p>
<p>Writing a custom memory manager is to optimize allocation for objects of a specific class, not for a class or any of its derived classes. Given an operator new for a class X, the behavior of that function is typically tuned for objects of size sizeof(X). But the operator new in a base class will be called to allocate memory for an object of a derived class. So Base’s class-specific operator new must design to cope with this</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (size != <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Base)) &#123;<br>        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in"><span class="hljs-keyword">new</span></span>(size);<br>      &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>The operator new[] and the operator have same problem.</p>
<h1 id="write-placement-delete-if-you-write-placement-new"><a class="markdownIt-Anchor" href="#write-placement-delete-if-you-write-placement-new"></a> Write placement delete if you write placement new</h1>
<p>When write a new expression to create object</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Widget* pw = <span class="hljs-keyword">new</span> Widget;<br></code></pre></td></tr></table></figure>
<p>Two functions are call: one to operator new to allocate memory, a second to Widget’s default constructor.</p>
<p>Suppose that first call succeeds, but the second call result in an exception being thrown, the memory allocation performed in step 1 must be undone. The responsibility for undoing step 1 must therefore fall on the C++ runtime system.</p>
<p>When a operator new function takes extra parameters, that function is known as a placement version of new.</p>
<p>The runtime system looks for a version of oeprator delete that takes the same number and types of extra arguments as operator new.</p>
<p>If an operator new with extra parameters isn’t matched by an operator delete with the same extra parameters, no operator delete will be call if a memory allocation by the new needs to be undone.</p>
<p>Placement delete is called only if an exception arises from a constructor call that’s coupled to a call to a placement. Applying delete to a pointer NEVER yields a call to a placement version of delete.</p>
<p>So, you must provide both the normal operator delete and a placement version that takes the same extra arguments as operator new does.</p>
<p>But member function names hide functions with the same names in outer scopes. So you need to remember is that by default, C++ offers the following forms of operator new at global scope.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span>)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">void</span>*)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">const</span> std::<span class="hljs-keyword">nothrow_t</span>&amp;)</span> <span class="hljs-keyword">throw</span></span>;<br></code></pre></td></tr></table></figure>
<p>If you declare any operator news in a class, you’ll hide all these standard forms.<br />
An easy way to do this is to create a base class containing all the normal forms of new and delete</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandardNewDeleteForms</span> &#123;</span><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in"><span class="hljs-keyword">new</span></span>(size);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *pMemory)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span>&#123;<br>      ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pMemory)</span></span>;<br>    &#125;<br>    ...<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>:</span> <span class="hljs-keyword">public</span> StandardNewDeleteForms &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> StandardNewDeleteForms::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>;<br>    <span class="hljs-keyword">using</span> StandardNewDeleteForms::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="pay-attention-to-compiler-warnings"><a class="markdownIt-Anchor" href="#pay-attention-to-compiler-warnings"></a> Pay attention to compiler warnings</h1>
<p>Take compiler warnings seriously, and strive to compile warning-free at the maximum warning level supported by your compilers.</p>
<p>Don’t become dependent on compiler warnings, because different compilers warn about different things. Porting to a new compiler may eliminate warning messages you’ve come to rely on.</p>
<h1 id="familiarize-yourself-with-the-standard-library-including-tr1"><a class="markdownIt-Anchor" href="#familiarize-yourself-with-the-standard-library-including-tr1"></a> Familiarize yourself with the standard library, including TR1.</h1>
<p>Major parts of the standard C++ library specified by C++98</p>
<ul>
<li>THe Standard Template Library(STL)</li>
<li>Iostreams</li>
<li>Support for internationalization</li>
<li>Support for numeric processing</li>
<li>An exception hierarchy</li>
<li>C89’s standard library</li>
</ul>
<h1 id="familiarize-yourself-with-boost"><a class="markdownIt-Anchor" href="#familiarize-yourself-with-boost"></a> Familiarize yourself with Boost</h1>
<p>Boost is a community and web site for the development of free, open source, peer-reviewed C++ libraries. Boost plays an influential role in C++ standardization.</p>
<p>Boost offers implementations of many TR1 components, but it also offers many other libraries, too.</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/12/10/20211128-Vim%20Command/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/09/30/20210930-Importance%20Sampling/">
                        <span class="hidden-mobile">Importance Sampling</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"c9e92fe53c4f7c10bae4","clientSecret":"a096f7a1a72bea29b07f9fba28fe0b05856f1b8c","repo":"git","owner":"493488419@qq.com","admin":[],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: 'fae7ca06d002e6bcc51e26750ea8fa43'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     #<a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> #<i class="iconfont icon-love"></i> #<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css" />
  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
